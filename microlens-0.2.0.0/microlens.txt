-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A tiny part of the lens library which you can depend upon
--   
--   This is an extract from <a>lens</a> (with no dependencies). It's not a
--   toy lenses library, unsuitable for “real world”, but merely a small
--   one. It is compatible with lens, and should have same performance. It
--   also has better documentation.
--   
--   Use this library:
--   
--   <ul>
--   <li>if you want to define lenses or traversals in your own library,
--   but don't want to depend on lens</li>
--   <li>if you are new to lenses and want a small library to play with,
--   but don't want to use something “inferior” or have to relearn things
--   when/if you switch to lens</li>
--   </ul>
--   
--   Don't use this library:
--   
--   <ul>
--   <li>if you need <tt>Iso</tt>s, <tt>Prism</tt>s, indexed traversals, or
--   actually anything else which isn't defined here</li>
--   <li>if you think lenses compose “in the wrong order” (in which case
--   you're looking for <a>fclabels</a>)</li>
--   </ul>
--   
--   Note that microlens has <i>no</i> dependencies starting from GHC 7.10
--   (base-4.8). Prior to that, it has to depend on transformers-0.2 or
--   above.
--   
--   Also note that it's not done yet and there's a lot of things missing.
@package microlens
@version 0.2.0.0


-- | This module provides just the types (<a>Lens</a>, <a>Traversal</a>,
--   etc). It's needed to break the dependency cycle – <a>Lens.Micro</a>
--   depends on <a>Lens.Micro.Classes</a>, but <a>Lens.Micro.Classes</a>
--   needs types like <a>Lens</a>, so <a>Lens</a> can't be defined in
--   <a>Lens.Micro</a>.
module Lens.Micro.Type

-- | <tt>ASetter s t a b</tt> is something that turns a function modifying
--   a value into a function modifying a <i>structure</i>. If you ignore
--   <a>Identity</a> (as <tt>Identity a</tt> is the same thing as
--   <tt>a</tt>), the type is:
--   
--   <pre>
--   type ASetter s t a b = (a -&gt; b) -&gt; s -&gt; t
--   </pre>
--   
--   This means that examples of setters you might've already seen are:
--   
--   <ul>
--   <li><pre><a>map</a> :: (a -&gt; b) -&gt; [a] -&gt; [b]</pre></li>
--   </ul>
--   
--   (which corresponds to <a>mapped</a>)
--   
--   <ul>
--   <li><pre><a>fmap</a> :: <a>Functor</a> f =&gt; (a -&gt; b) -&gt; f a
--   -&gt; f b</pre></li>
--   </ul>
--   
--   (which corresponds to <a>mapped</a> as well)
--   
--   <ul>
--   <li><pre><a>first</a> :: (a -&gt; b) -&gt; (a, x) -&gt; (b,
--   x)</pre></li>
--   </ul>
--   
--   (which corresponds to <a>_1</a>)
--   
--   <ul>
--   <li><pre><a>left</a> :: (a -&gt; b) -&gt; <a>Either</a> a x -&gt;
--   <a>Either</a> b x</pre></li>
--   </ul>
--   
--   (which corresponds to <a>_Left</a>)
--   
--   The reason <a>Identity</a> is used here is for <a>ASetter</a> to be
--   composable with other types, such as <a>Lens</a>.
--   
--   Technically, if you're writing a library, you shouldn't use this type
--   for setters you are exporting from your library; the right type to use
--   is <tt><a>Setter</a></tt>, but it is not provided by this package
--   (because then we'd have to depend on <a>distributive</a>). It's
--   completely alright, however, to export functions which take an
--   <a>ASetter</a> as an argument.
type ASetter s t a b = (a -> Identity b) -> s -> Identity t

-- | This is a type alias for monomorphic setters which don't change the
--   type of the container (or of the value inside). It's useful more often
--   than the same type in lens, because we can't provide real setters and
--   so it does the job of both <tt><a>ASetter'</a></tt> and
--   <tt><a>Setter'</a></tt>.
type ASetter' s a = ASetter s s a a

-- | If you take a lens or a traversal and choose <tt><a>Const</a> r</tt>
--   as your functor, you will get <tt>Getting r s a</tt>. This can be used
--   to get something out of the structure instead of modifying it:
--   
--   <pre>
--   s <a>^.</a> l = <a>getConst</a> (l <a>Const</a> s)
--   </pre>
--   
--   Functions that operate on getters – such as (<a>^.</a>), (<a>^..</a>),
--   (<a>^?</a>) – use <tt>Getter r s a</tt> (with different values of
--   <tt>r</tt>) to describe what kind of getter they need. For instance,
--   (<a>^.</a>) needs the getter to be able to return a single value, and
--   so it accepts a getter of type <tt>Getting a s a</tt>. (<a>^..</a>)
--   wants the getter to gather values together, so it uses <tt>Getting
--   (Endo [a]) s a</tt> (it could've used <tt>Getting [a] s a</tt>
--   instead, but it's faster with <a>Endo</a>). The choice of <tt>r</tt>
--   depends on what you want to do with elements you're extracting from
--   <tt>s</tt>.
type Getting r s a = (a -> Const r a) -> s -> Const r s

-- | Lenses in a nutshell: use (<a>^.</a>) to get, (<a>.~</a>) to set,
--   (<a>%~</a>) to modify. (<a>.</a>) composes lenses (i.e. if a
--   <tt>B</tt> is a part of <tt>A</tt>, and a <tt>C</tt> is a part of in
--   <tt>B</tt>, then <tt>b.c</tt> lets you operate on <tt>C</tt> inside
--   <tt>A</tt>). You can create lenses with <a>lens</a>, or you can write
--   them by hand (see below).
--   
--   <tt>Lens s t a b</tt> is the lowest common denominator of a setter and
--   a getter, something that has the power of both; it has a
--   <a>Functor</a> constraint, and since both <a>Const</a> and
--   <a>Identity</a> are functors, it can be used whenever a getter or a
--   setter is needed.
--   
--   <ul>
--   <li><tt>a</tt> is the type of the value inside of structure</li>
--   <li><tt>b</tt> is the type of the replaced value</li>
--   <li><tt>s</tt> is the type of the whole structure</li>
--   <li><tt>t</tt> is the type of the structure after replacing <tt>a</tt>
--   in it with <tt>b</tt></li>
--   </ul>
--   
--   A <a>Lens</a> can only point at a single value inside a structure
--   (unlike a <a>Traversal</a>).
--   
--   It is easy to write lenses manually. The generic template is:
--   
--   <pre>
--   somelens :: Lens s t a b
--   
--   -- “f” is the “a -&gt; f b” function, “s” is the structure.
--   somelens f s =
--     let
--       a = ...                 -- Extract the value from “s”.
--       rebuildWith b = ...     -- Write a function which would
--                               -- combine “s” and modified value
--                               -- to produce new structure.
--     in
--       rebuildWith <a>&lt;$&gt;</a> f a     -- Apply the structure-producing
--                               -- function to the modified value.
--   </pre>
--   
--   Here's the <a>_1</a> lens:
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a, x) (b, x) a b
--   <a>_1</a> f (a, x) = (\b -&gt; (b, x)) <a>&lt;$&gt;</a> f a
--   </pre>
--   
--   Here's a more complicated lens, which extracts <i>several</i> values
--   from a structure (in a tuple):
--   
--   <pre>
--   type Age     = Int
--   type City    = String
--   type Country = String
--   
--   data Person = Person Age City Country
--   
--   -- This lens lets you access all location-related information about a person.
--   location :: <a>Lens'</a> Person (City, Country)
--   location f (Person age city country) =
--     (\(city', country') -&gt; Person age city' country') <a>&lt;$&gt;</a> f (city, country)
--   </pre>
--   
--   You even can choose to use a lens to present <i>all</i> information
--   contained in the structure (in a different way). Such lenses are
--   called <tt><a>Iso</a></tt> in lens's terminology. For instance
--   (assuming you don't mind functions that can error out), here's a lens
--   which lets you act on the string representation of a value:
--   
--   <pre>
--   string :: (Read a, Show a) =&gt; <a>Lens'</a> a String
--   string f s = read <a>&lt;$&gt;</a> f (show s)
--   </pre>
--   
--   Using it to reverse a number:
--   
--   <pre>
--   &gt;&gt;&gt; 123 <a>&amp;</a> string <a>%~</a> reverse
--   321
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | This is a type alias for monomorphic lenses which don't change the
--   type of the container (or of the value inside).
type Lens' s a = Lens s s a a

-- | Traversals in a nutshell: they're like lenses but they can point at
--   multiple values. Use (<a>^..</a>) to get all values, (<a>^?</a>) to
--   get the 1st value, (<a>.~</a>) to set values, (<a>%~</a>) to modify
--   them. (<a>.</a>) composes traversals just as it composes lenses.
--   (<a>^.</a>) can be used with traversals as well, but don't confuse it
--   with (<a>^..</a>).
--   
--   <tt>Traversal s t a b</tt> is a generalisation of <a>Lens</a> which
--   allows many targets (possibly 0). It's achieved by changing the
--   constraint to <a>Applicative</a> instead of <a>Functor</a> – indeed,
--   the point of <a>Applicative</a> is that you can combine effects, which
--   is just what we need to have many targets.
--   
--   Traversals don't differ from lenses when it comes to setting – you can
--   use usual (<a>%~</a>) and (<a>.~</a>) to modify and set values.
--   Getting is a bit different, because you have to decide what to do in
--   the case of multiple values. In particular, you can use these
--   combinators (as well as everything else in the “Folds” section):
--   
--   <ul>
--   <li>(<a>^..</a>) gets a list of values</li>
--   <li>(<a>^?</a>) gets the 1st value (or <a>Nothing</a> if there are no
--   values)</li>
--   <li>(<a>^?!</a>) gets the 1st value and throws an exception if there
--   are no values</li>
--   </ul>
--   
--   In addition, (<a>^.</a>) works for traversals as well – it combines
--   traversed values using the (<a>&lt;&gt;</a>) operation (if the values
--   are instances of <a>Monoid</a>).
--   
--   Traversing any value twice is a violation of traversal laws. You can,
--   however, traverse values in any order.
--   
--   Ultimately, traversals should follow 2 laws:
--   
--   <pre>
--   t pure ≡ pure
--   fmap (t f) . t g ≡ getCompose . t (Compose . fmap f . g)
--   </pre>
--   
--   The 1st law states that you can't change the shape of the structure or
--   do anything funny with elements (traverse elements which aren't in the
--   structure, create new elements out of thin air, etc.). The 2nd law
--   states that you should be able to fuse 2 identical traversals into
--   one. For a more detailed explanation of the laws, see <a>this blog
--   post</a> (if you prefer rambling blog posts), or <a>The Essence Of The
--   Iterator Pattern</a> (if you prefer papers).
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | This is a type alias for monomorphic traversals which don't change the
--   type of the container (or of the values inside).
type Traversal' s a = Traversal s s a a


-- | This module is needed to give other packages from the microlens family
--   (like <a>microlens-ghc</a>) access to functions that don't need to be
--   exported from <a>Lens.Micro</a> (because they just clutter the
--   namespace). Also, okay, uh, e.g. <a>traversed</a> is here because
--   otherwise there'd be a dependency cycle.
module Lens.Micro.Internal

-- | <a>traversed</a> traverses any <a>Traversable</a> container (list,
--   vector, <tt>Map</tt>, <a>Maybe</a>, you name it):
--   
--   <pre>
--   &gt;&gt;&gt; Just 1 ^.. traversed
--   [1]
--   </pre>
--   
--   <a>traversed</a> is the same as <a>traverse</a>, but can be faster
--   thanks to magic rewrite rules.
traversed :: Traversable f => Traversal (f a) (f b) a b

-- | <a>folded</a> is a fold for anything <a>Foldable</a>. In a way, it's
--   an opposite of <tt>mapped</tt> – the most powerful getter, but can't
--   be used as a setter.
folded :: (Foldable f, Applicative (Const r)) => Getting r (f a) a
foldring :: (Applicative (Const r)) => ((a -> Const r a -> Const r a) -> Const r a -> s -> Const r a) -> (a -> Const r b) -> s -> Const r t
foldrOf :: Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r
foldMapOf :: Getting r s a -> (a -> r) -> s -> r

-- | <a>sets</a> creates an <a>ASetter</a> from an ordinary function. (The
--   only thing it does is wrapping and unwrapping <a>Identity</a>.)
sets :: ((a -> b) -> s -> t) -> ASetter s t a b
(#.) :: Coercible c b => (b -> c) -> (a -> b) -> (a -> c)
(.#) :: Coercible b a => (b -> c) -> (a -> b) -> (a -> c)

module Lens.Micro.Classes
class Each s t a b | s -> a, t -> b, s b -> t, t a -> s where each = traverse

-- | <a>each</a> tries to be a universal <a>Traversal</a> – it behaves like
--   <a>traversed</a> in most situations, but also adds support for e.g.
--   tuples with same-typed values:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; each %~ succ
--   (2,3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ["x", "y", "z"] ^. each
--   "xyz"
--   </pre>
--   
--   However, note that <a>each</a> doesn't work on <i>every</i> instance
--   of <a>Traversable</a>. If you have a <a>Traversable</a> which isn't
--   supported by <a>each</a>, you can use <a>traversed</a> instead.
--   Personally, I like using <a>each</a> instead of <a>traversed</a>
--   whenever possible – it's shorter and more descriptive.
--   
--   You can use <a>each</a> with these things:
--   
--   <pre>
--   <a>each</a> :: <a>Traversal</a> [a] [b] a b
--   
--   <a>each</a> :: <a>Traversal</a> (<a>Maybe</a> a) (<a>Maybe</a> b) a b
--   
--   <a>each</a> :: <a>Traversal</a> (a,a) (b,b) a b
--   <a>each</a> :: <a>Traversal</a> (a,a,a) (b,b,b) a b
--   <a>each</a> :: <a>Traversal</a> (a,a,a,a) (b,b,b,b) a b
--   <a>each</a> :: <a>Traversal</a> (a,a,a,a,a) (b,b,b,b,b) a b
--   
--   <a>each</a> :: (<a>RealFloat</a> a, <a>RealFloat</a> b) =&gt; <a>Traversal</a> (<a>Complex</a> a) (<a>Complex</a> b) a b
--   </pre>
--   
--   Additionally, you can use <a>each</a> with types from <a>array</a>,
--   <a>bytestring</a>, and <a>containers</a> by importing
--   <tt>Lens.Micro.GHC</tt> from the <a>microlens-ghc</a> package.
each :: Each s t a b => Traversal s t a b
class Ixed m where ix = ixAt

-- | This traversal lets you access (and update) an arbitrary element in a
--   list, array, <tt>Map</tt>, etc. (If you want to insert or delete
--   elements as well, look at <a>at</a>.)
--   
--   An example for lists:
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 3 .~ 10
--   [0,1,2,100,4,5]
--   </pre>
--   
--   You can use it for getting, too:
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] ^? ix 3
--   Just 3
--   </pre>
--   
--   Of course, the element may not be present (which means that you can
--   use <a>ix</a> as a safe variant of (<a>!!</a>)):
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] ^? ix 10
--   Nothing
--   </pre>
--   
--   Another useful instance is the one for functions – it lets you modify
--   their outputs for specific inputs. For instance, here's <a>maximum</a>
--   that returns 0 when the list is empty (instead of throwing an
--   exception):
--   
--   <pre>
--   maximum0 = <a>maximum</a> <a>&amp;</a> <a>ix</a> [] <a>.~</a> 0
--   </pre>
--   
--   The following instances are provided in this package:
--   
--   <pre>
--   <a>ix</a> :: <a>Int</a> -&gt; <a>Traversal'</a> [a] a
--   
--   <a>ix</a> :: (<a>Eq</a> e) =&gt; e -&gt; <a>Traversal'</a> (e -&gt; a) a
--   </pre>
--   
--   Additionally, you can use <a>ix</a> with types from <a>array</a>,
--   <a>bytestring</a>, and <a>containers</a> by importing
--   <tt>Lens.Micro.GHC</tt> from the <a>microlens-ghc</a> package.
ix :: Ixed m => Index m -> Traversal' m (IxValue m)
class Ixed m => At m

-- | This lens lets you read, write, or delete elements in
--   <tt>Map</tt>-like structures. It returns <a>Nothing</a> when the value
--   isn't found, just like <tt>lookup</tt>:
--   
--   <pre>
--   Data.Map.lookup k m = m <a>^.</a> at k
--   </pre>
--   
--   However, it also lets you insert and delete values by setting the
--   value to <tt><a>Just</a> value</tt> or <a>Nothing</a>:
--   
--   <pre>
--   Data.Map.insert k a m = m <a>&amp;</a> at k <a>.~</a> Just a
--   
--   Data.Map.delete k m = m <a>&amp;</a> at k <a>.~</a> Nothing
--   </pre>
--   
--   <a>at</a> doesn't work for arrays, because you can't delete an
--   arbitrary element from an array.
--   
--   If you want to modify an already existing value, you should use
--   <a>ix</a> instead because then you won't have to deal with
--   <a>Maybe</a> (<a>ix</a> is available for all types that have
--   <a>at</a>).
--   
--   This package doesn't actually provide any instances for <a>at</a>, but
--   you can import <tt>Lens.Micro.GHC</tt> from the <a>microlens-ghc</a>
--   package and get instances for <tt>Map</tt> and <tt>IntMap</tt>.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Gives access to the 1st field of a tuple (up to 5-tuples).
--   
--   Getting the 1st component:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) ^. _1
--   1
--   </pre>
--   
--   Setting the 1st component:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3) &amp; _1 .~ 10
--   (10,2,3)
--   </pre>
--   
--   Note that this lens is lazy, and can set fields even of
--   <a>undefined</a>:
--   
--   <pre>
--   &gt;&gt;&gt; set _1 10 undefined :: (Int, Int)
--   (10,*** Exception: Prelude.undefined
--   </pre>
--   
--   This is done to avoid violating a lens law stating that you can get
--   back what you put:
--   
--   <pre>
--   &gt;&gt;&gt; view _1 . set _1 10 $ (undefined :: (Int, Int))
--   10
--   </pre>
--   
--   The implementation (for 2-tuples) is:
--   
--   <pre>
--   <a>_1</a> f t = (,) <a>&lt;$&gt;</a> f    (<a>fst</a> t)
--                <a>&lt;*&gt;</a> <a>pure</a> (<a>snd</a> t)
--   </pre>
--   
--   or, alternatively,
--   
--   <pre>
--   <a>_1</a> f ~(a,b) = (\a' -&gt; (a',b)) <a>&lt;$&gt;</a> f a
--   </pre>
--   
--   (where <tt>~</tt> means a <a>lazy pattern</a>).
--   
--   <a>_2</a>, <a>_3</a>, <a>_4</a>, and <a>_5</a> are also available (see
--   below).
_1 :: Field1 s t a b => Lens s t a b
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s
_2 :: Field2 s t a b => Lens s t a b
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s
_3 :: Field3 s t a b => Lens s t a b
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s
_4 :: Field4 s t a b => Lens s t a b
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s
_5 :: Field5 s t a b => Lens s t a b
instance (a ~ b, q ~ r) => Lens.Micro.Classes.Each (a, b) (q, r) a q
instance (a ~ b, a ~ c, q ~ r, q ~ s) => Lens.Micro.Classes.Each (a, b, c) (q, r, s) a q
instance (a ~ b, a ~ c, a ~ d, q ~ r, q ~ s, q ~ t) => Lens.Micro.Classes.Each (a, b, c, d) (q, r, s, t) a q
instance (a ~ b, a ~ c, a ~ d, a ~ e, q ~ r, q ~ s, q ~ t, q ~ u) => Lens.Micro.Classes.Each (a, b, c, d, e) (q, r, s, t, u) a q
instance Lens.Micro.Classes.Each (Data.Complex.Complex a) (Data.Complex.Complex b) a b
instance Lens.Micro.Classes.Each [a] [b] a b
instance Lens.Micro.Classes.Each (GHC.Base.Maybe a) (GHC.Base.Maybe b) a b
instance GHC.Classes.Eq e => Lens.Micro.Classes.Ixed (e -> a)
instance Lens.Micro.Classes.Ixed [a]
instance Lens.Micro.Classes.Field1 (a, b) (a', b) a a'
instance Lens.Micro.Classes.Field1 (a, b, c) (a', b, c) a a'
instance Lens.Micro.Classes.Field1 (a, b, c, d) (a', b, c, d) a a'
instance Lens.Micro.Classes.Field1 (a, b, c, d, e) (a', b, c, d, e) a a'
instance Lens.Micro.Classes.Field2 (a, b) (a, b') b b'
instance Lens.Micro.Classes.Field2 (a, b, c) (a, b', c) b b'
instance Lens.Micro.Classes.Field2 (a, b, c, d) (a, b', c, d) b b'
instance Lens.Micro.Classes.Field2 (a, b, c, d, e) (a, b', c, d, e) b b'
instance Lens.Micro.Classes.Field3 (a, b, c) (a, b, c') c c'
instance Lens.Micro.Classes.Field3 (a, b, c, d) (a, b, c', d) c c'
instance Lens.Micro.Classes.Field3 (a, b, c, d, e) (a, b, c', d, e) c c'
instance Lens.Micro.Classes.Field4 (a, b, c, d) (a, b, c, d') d d'
instance Lens.Micro.Classes.Field4 (a, b, c, d, e) (a, b, c, d', e) d d'
instance Lens.Micro.Classes.Field5 (a, b, c, d, e) (a, b, c, d, e') e e'

module Lens.Micro

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
(&) :: a -> (a -> b) -> b

-- | <tt>ASetter s t a b</tt> is something that turns a function modifying
--   a value into a function modifying a <i>structure</i>. If you ignore
--   <a>Identity</a> (as <tt>Identity a</tt> is the same thing as
--   <tt>a</tt>), the type is:
--   
--   <pre>
--   type ASetter s t a b = (a -&gt; b) -&gt; s -&gt; t
--   </pre>
--   
--   This means that examples of setters you might've already seen are:
--   
--   <ul>
--   <li><pre><a>map</a> :: (a -&gt; b) -&gt; [a] -&gt; [b]</pre></li>
--   </ul>
--   
--   (which corresponds to <a>mapped</a>)
--   
--   <ul>
--   <li><pre><a>fmap</a> :: <a>Functor</a> f =&gt; (a -&gt; b) -&gt; f a
--   -&gt; f b</pre></li>
--   </ul>
--   
--   (which corresponds to <a>mapped</a> as well)
--   
--   <ul>
--   <li><pre><a>first</a> :: (a -&gt; b) -&gt; (a, x) -&gt; (b,
--   x)</pre></li>
--   </ul>
--   
--   (which corresponds to <a>_1</a>)
--   
--   <ul>
--   <li><pre><a>left</a> :: (a -&gt; b) -&gt; <a>Either</a> a x -&gt;
--   <a>Either</a> b x</pre></li>
--   </ul>
--   
--   (which corresponds to <a>_Left</a>)
--   
--   The reason <a>Identity</a> is used here is for <a>ASetter</a> to be
--   composable with other types, such as <a>Lens</a>.
--   
--   Technically, if you're writing a library, you shouldn't use this type
--   for setters you are exporting from your library; the right type to use
--   is <tt><a>Setter</a></tt>, but it is not provided by this package
--   (because then we'd have to depend on <a>distributive</a>). It's
--   completely alright, however, to export functions which take an
--   <a>ASetter</a> as an argument.
type ASetter s t a b = (a -> Identity b) -> s -> Identity t

-- | This is a type alias for monomorphic setters which don't change the
--   type of the container (or of the value inside). It's useful more often
--   than the same type in lens, because we can't provide real setters and
--   so it does the job of both <tt><a>ASetter'</a></tt> and
--   <tt><a>Setter'</a></tt>.
type ASetter' s a = ASetter s s a a

-- | <a>sets</a> creates an <a>ASetter</a> from an ordinary function. (The
--   only thing it does is wrapping and unwrapping <a>Identity</a>.)
sets :: ((a -> b) -> s -> t) -> ASetter s t a b

-- | (<a>%~</a>) applies a function to the target; an alternative
--   explanation is that it is an inverse of <a>sets</a>, which turns a
--   setter into an ordinary function. <tt><a>mapped</a> <a>%~</a>
--   <a>reverse</a></tt> is the same thing as <tt><a>fmap</a>
--   <a>reverse</a></tt>.
--   
--   See <a>over</a> if you want a non-operator synonym.
--   
--   Negating the 1st element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 %~ negate
--   (-1,2)
--   </pre>
--   
--   Turning all <tt>Left</tt>s in a list to upper case:
--   
--   <pre>
--   &gt;&gt;&gt; (mapped._Left.mapped %~ toUpper) [Left "foo", Right "bar"]
--   [Left "FOO",Right "bar"]
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t

-- | <a>over</a> is a synonym for (<a>%~</a>).
--   
--   Getting <a>fmap</a> in a roundabout way:
--   
--   <pre>
--   <a>over</a> <a>mapped</a> :: <a>Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   <a>over</a> <a>mapped</a> = <a>fmap</a>
--   </pre>
--   
--   Applying a function to both components of a pair:
--   
--   <pre>
--   <a>over</a> <a>both</a> :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)
--   <a>over</a> <a>both</a> = \f t -&gt; (f (fst t), f (snd t))
--   </pre>
--   
--   Using <tt><a>over</a> <a>_2</a></tt> as a replacement for
--   <a>second</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _2 show (10,20)
--   (10,"20")
--   </pre>
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | (<a>.~</a>) assigns a value to the target. These are equivalent:
--   
--   <ul>
--   <li><pre>l <a>.~</a> x</pre></li>
--   <li><pre>l <a>%~</a> <a>const</a> x</pre></li>
--   </ul>
--   
--   See <a>set</a> if you want a non-operator synonym.
--   
--   Here it is used to change 2 fields of a 3-tuple:
--   
--   <pre>
--   &gt;&gt;&gt; (0,0,0) &amp; _1 .~ 1 &amp; _3 .~ 3
--   (1,0,3)
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t

-- | <a>set</a> is a synonym for (<a>.~</a>).
--   
--   Setting the 1st component of a pair:
--   
--   <pre>
--   <a>set</a> <a>_1</a> :: x -&gt; (a, b) -&gt; (x, b)
--   <a>set</a> <a>_1</a> = \x t -&gt; (x, snd t)
--   </pre>
--   
--   Using it to rewrite (<a>&lt;$</a>):
--   
--   <pre>
--   <a>set</a> <a>mapped</a> :: <a>Functor</a> f =&gt; a -&gt; f b -&gt; f a
--   <a>set</a> <a>mapped</a> = (<a>&lt;$</a>)
--   </pre>
set :: ASetter s t a b -> b -> s -> t

-- | <a>mapped</a> is a setter for everything contained in a functor. You
--   can use it to map over lists, <tt>Maybe</tt>, or even <tt>IO</tt>
--   (which is something you can't do with <a>traversed</a> or
--   <a>each</a>).
--   
--   Here <a>mapped</a> is used to turn a value to all non-<a>Nothing</a>
--   values in a list:
--   
--   <pre>
--   &gt;&gt;&gt; [Just 3,Nothing,Just 5] &amp; mapped.mapped .~ 0
--   [Just 0,Nothing,Just 0]
--   </pre>
--   
--   Keep in mind that while <a>mapped</a> is a more powerful setter than
--   <a>each</a>, it can't be used as a getter! This won't work (and will
--   fail with a type error):
--   
--   <pre>
--   [(1,2),(3,4),(5,6)] <a>^..</a> <a>mapped</a> . <a>both</a>
--   </pre>
mapped :: Functor f => ASetter (f a) (f b) a b

-- | If you take a lens or a traversal and choose <tt><a>Const</a> r</tt>
--   as your functor, you will get <tt>Getting r s a</tt>. This can be used
--   to get something out of the structure instead of modifying it:
--   
--   <pre>
--   s <a>^.</a> l = <a>getConst</a> (l <a>Const</a> s)
--   </pre>
--   
--   Functions that operate on getters – such as (<a>^.</a>), (<a>^..</a>),
--   (<a>^?</a>) – use <tt>Getter r s a</tt> (with different values of
--   <tt>r</tt>) to describe what kind of getter they need. For instance,
--   (<a>^.</a>) needs the getter to be able to return a single value, and
--   so it accepts a getter of type <tt>Getting a s a</tt>. (<a>^..</a>)
--   wants the getter to gather values together, so it uses <tt>Getting
--   (Endo [a]) s a</tt> (it could've used <tt>Getting [a] s a</tt>
--   instead, but it's faster with <a>Endo</a>). The choice of <tt>r</tt>
--   depends on what you want to do with elements you're extracting from
--   <tt>s</tt>.
type Getting r s a = (a -> Const r a) -> s -> Const r s

-- | (<a>^.</a>) applies a getter to a value; in other words, it gets a
--   value out of a structure using a getter (which can be a lens,
--   traversal, fold, etc.).
--   
--   Getting 1st field of a tuple:
--   
--   <pre>
--   (<a>^.</a> <a>_1</a>) :: (a, b) -&gt; a
--   (<a>^.</a> <a>_1</a>) = <a>fst</a>
--   </pre>
--   
--   When (<a>^.</a>) is used with a traversal, it combines all results
--   using the <a>Monoid</a> instance for the resulting type. For instance,
--   for lists it would be simple concatenation:
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") ^. each
--   "string"
--   </pre>
--   
--   The reason for this is that traversals use <a>Applicative</a>, and the
--   <a>Applicative</a> instance for <a>Const</a> uses monoid concatenation
--   to combine “effects” of <a>Const</a>.
(^.) :: s -> Getting a s a -> a

-- | <tt>s ^.. t</tt> returns the list of all values that <tt>t</tt> gets
--   from <tt>s</tt>.
--   
--   A <a>Maybe</a> contains either 0 or 1 values:
--   
--   <pre>
--   &gt;&gt;&gt; Just 3 ^.. _Just
--   [3]
--   </pre>
--   
--   Gathering all values in a list of tuples:
--   
--   <pre>
--   &gt;&gt;&gt; [(1,2),(3,4)] ^.. each.each
--   [1,2,3,4]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]

-- | <tt>s ^? t</tt> returns the 1st element <tt>t</tt> returns, or
--   <a>Nothing</a> if <tt>t</tt> doesn't return anything. It's trivially
--   implemented by passing the <a>First</a> monoid to the getter.
--   
--   Safe <a>head</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? each
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..3] ^? each
--   Just 1
--   </pre>
--   
--   Converting <a>Either</a> to <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 1 ^? _Right
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 1 ^? _Right
--   Just 1
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a

-- | (<a>^?!</a>) is an unsafe variant of (<a>^?</a>) – instead of using
--   <a>Nothing</a> to indicate that there were no elements returned, it
--   throws an exception.
(^?!) :: s -> Getting (Endo a) s a -> a

-- | <a>folded</a> is a fold for anything <a>Foldable</a>. In a way, it's
--   an opposite of <tt>mapped</tt> – the most powerful getter, but can't
--   be used as a setter.
folded :: (Foldable f, Applicative (Const r)) => Getting r (f a) a

-- | <a>has</a> checks whether a getter (any getter, including lenses,
--   traversals, and folds) returns at least 1 value.
--   
--   Checking whether a list is non-empty:
--   
--   <pre>
--   &gt;&gt;&gt; has each []
--   False
--   </pre>
--   
--   You can also use it with e.g. <a>_Left</a> (and other 0-or-1
--   traversals) as a replacement for <a>isNothing</a>, <a>isJust</a> and
--   other <tt>isConstructorName</tt> functions:
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 1)
--   True
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Lenses in a nutshell: use (<a>^.</a>) to get, (<a>.~</a>) to set,
--   (<a>%~</a>) to modify. (<a>.</a>) composes lenses (i.e. if a
--   <tt>B</tt> is a part of <tt>A</tt>, and a <tt>C</tt> is a part of in
--   <tt>B</tt>, then <tt>b.c</tt> lets you operate on <tt>C</tt> inside
--   <tt>A</tt>). You can create lenses with <a>lens</a>, or you can write
--   them by hand (see below).
--   
--   <tt>Lens s t a b</tt> is the lowest common denominator of a setter and
--   a getter, something that has the power of both; it has a
--   <a>Functor</a> constraint, and since both <a>Const</a> and
--   <a>Identity</a> are functors, it can be used whenever a getter or a
--   setter is needed.
--   
--   <ul>
--   <li><tt>a</tt> is the type of the value inside of structure</li>
--   <li><tt>b</tt> is the type of the replaced value</li>
--   <li><tt>s</tt> is the type of the whole structure</li>
--   <li><tt>t</tt> is the type of the structure after replacing <tt>a</tt>
--   in it with <tt>b</tt></li>
--   </ul>
--   
--   A <a>Lens</a> can only point at a single value inside a structure
--   (unlike a <a>Traversal</a>).
--   
--   It is easy to write lenses manually. The generic template is:
--   
--   <pre>
--   somelens :: Lens s t a b
--   
--   -- “f” is the “a -&gt; f b” function, “s” is the structure.
--   somelens f s =
--     let
--       a = ...                 -- Extract the value from “s”.
--       rebuildWith b = ...     -- Write a function which would
--                               -- combine “s” and modified value
--                               -- to produce new structure.
--     in
--       rebuildWith <a>&lt;$&gt;</a> f a     -- Apply the structure-producing
--                               -- function to the modified value.
--   </pre>
--   
--   Here's the <a>_1</a> lens:
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a, x) (b, x) a b
--   <a>_1</a> f (a, x) = (\b -&gt; (b, x)) <a>&lt;$&gt;</a> f a
--   </pre>
--   
--   Here's a more complicated lens, which extracts <i>several</i> values
--   from a structure (in a tuple):
--   
--   <pre>
--   type Age     = Int
--   type City    = String
--   type Country = String
--   
--   data Person = Person Age City Country
--   
--   -- This lens lets you access all location-related information about a person.
--   location :: <a>Lens'</a> Person (City, Country)
--   location f (Person age city country) =
--     (\(city', country') -&gt; Person age city' country') <a>&lt;$&gt;</a> f (city, country)
--   </pre>
--   
--   You even can choose to use a lens to present <i>all</i> information
--   contained in the structure (in a different way). Such lenses are
--   called <tt><a>Iso</a></tt> in lens's terminology. For instance
--   (assuming you don't mind functions that can error out), here's a lens
--   which lets you act on the string representation of a value:
--   
--   <pre>
--   string :: (Read a, Show a) =&gt; <a>Lens'</a> a String
--   string f s = read <a>&lt;$&gt;</a> f (show s)
--   </pre>
--   
--   Using it to reverse a number:
--   
--   <pre>
--   &gt;&gt;&gt; 123 <a>&amp;</a> string <a>%~</a> reverse
--   321
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | This is a type alias for monomorphic lenses which don't change the
--   type of the container (or of the value inside).
type Lens' s a = Lens s s a a

-- | <a>lens</a> creates a <a>Lens</a> from a getter and a setter. The
--   resulting lens isn't the most effective one (because of having to
--   traverse the structure twice when modifying), but it shouldn't matter
--   much.
--   
--   A (partial) lens for list indexing:
--   
--   <pre>
--   ix :: Int -&gt; <a>Lens'</a> [a] a
--   ix i = <a>lens</a> (<a>!!</a> i)                                   -- getter
--               (\s b -&gt; take i s ++ b : drop (i+1) s)   -- setter
--   </pre>
--   
--   Usage:
--   
--   <pre>
--   &gt;&gt;&gt; [1..9] <a>^.</a> ix 3
--   4
--   
--   &gt;&gt;&gt; [1..9] &amp; ix 3 <a>%~</a> negate
--   [1,2,3,-4,5,6,7,8,9]
--   </pre>
--   
--   When getting, the setter is completely unused; when setting, the
--   getter is unused. Both are used only when the value is being modified.
--   For instance, here we define a lens for the 1st element of a list, but
--   instead of a legitimate getter we use <a>undefined</a>. Then we use
--   the resulting lens for <i>setting</i> and it works, which proves that
--   the getter wasn't used:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; lens undefined (\s b -&gt; b : tail s) .~ 10
--   [10,2,3]
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | This lens lets you read, write, or delete elements in
--   <tt>Map</tt>-like structures. It returns <a>Nothing</a> when the value
--   isn't found, just like <tt>lookup</tt>:
--   
--   <pre>
--   Data.Map.lookup k m = m <a>^.</a> at k
--   </pre>
--   
--   However, it also lets you insert and delete values by setting the
--   value to <tt><a>Just</a> value</tt> or <a>Nothing</a>:
--   
--   <pre>
--   Data.Map.insert k a m = m <a>&amp;</a> at k <a>.~</a> Just a
--   
--   Data.Map.delete k m = m <a>&amp;</a> at k <a>.~</a> Nothing
--   </pre>
--   
--   <a>at</a> doesn't work for arrays, because you can't delete an
--   arbitrary element from an array.
--   
--   If you want to modify an already existing value, you should use
--   <a>ix</a> instead because then you won't have to deal with
--   <a>Maybe</a> (<a>ix</a> is available for all types that have
--   <a>at</a>).
--   
--   This package doesn't actually provide any instances for <a>at</a>, but
--   you can import <tt>Lens.Micro.GHC</tt> from the <a>microlens-ghc</a>
--   package and get instances for <tt>Map</tt> and <tt>IntMap</tt>.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Gives access to the 1st field of a tuple (up to 5-tuples).
--   
--   Getting the 1st component:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) ^. _1
--   1
--   </pre>
--   
--   Setting the 1st component:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3) &amp; _1 .~ 10
--   (10,2,3)
--   </pre>
--   
--   Note that this lens is lazy, and can set fields even of
--   <a>undefined</a>:
--   
--   <pre>
--   &gt;&gt;&gt; set _1 10 undefined :: (Int, Int)
--   (10,*** Exception: Prelude.undefined
--   </pre>
--   
--   This is done to avoid violating a lens law stating that you can get
--   back what you put:
--   
--   <pre>
--   &gt;&gt;&gt; view _1 . set _1 10 $ (undefined :: (Int, Int))
--   10
--   </pre>
--   
--   The implementation (for 2-tuples) is:
--   
--   <pre>
--   <a>_1</a> f t = (,) <a>&lt;$&gt;</a> f    (<a>fst</a> t)
--                <a>&lt;*&gt;</a> <a>pure</a> (<a>snd</a> t)
--   </pre>
--   
--   or, alternatively,
--   
--   <pre>
--   <a>_1</a> f ~(a,b) = (\a' -&gt; (a',b)) <a>&lt;$&gt;</a> f a
--   </pre>
--   
--   (where <tt>~</tt> means a <a>lazy pattern</a>).
--   
--   <a>_2</a>, <a>_3</a>, <a>_4</a>, and <a>_5</a> are also available (see
--   below).
_1 :: Field1 s t a b => Lens s t a b
_2 :: Field2 s t a b => Lens s t a b
_3 :: Field3 s t a b => Lens s t a b
_4 :: Field4 s t a b => Lens s t a b
_5 :: Field5 s t a b => Lens s t a b

-- | Traversals in a nutshell: they're like lenses but they can point at
--   multiple values. Use (<a>^..</a>) to get all values, (<a>^?</a>) to
--   get the 1st value, (<a>.~</a>) to set values, (<a>%~</a>) to modify
--   them. (<a>.</a>) composes traversals just as it composes lenses.
--   (<a>^.</a>) can be used with traversals as well, but don't confuse it
--   with (<a>^..</a>).
--   
--   <tt>Traversal s t a b</tt> is a generalisation of <a>Lens</a> which
--   allows many targets (possibly 0). It's achieved by changing the
--   constraint to <a>Applicative</a> instead of <a>Functor</a> – indeed,
--   the point of <a>Applicative</a> is that you can combine effects, which
--   is just what we need to have many targets.
--   
--   Traversals don't differ from lenses when it comes to setting – you can
--   use usual (<a>%~</a>) and (<a>.~</a>) to modify and set values.
--   Getting is a bit different, because you have to decide what to do in
--   the case of multiple values. In particular, you can use these
--   combinators (as well as everything else in the “Folds” section):
--   
--   <ul>
--   <li>(<a>^..</a>) gets a list of values</li>
--   <li>(<a>^?</a>) gets the 1st value (or <a>Nothing</a> if there are no
--   values)</li>
--   <li>(<a>^?!</a>) gets the 1st value and throws an exception if there
--   are no values</li>
--   </ul>
--   
--   In addition, (<a>^.</a>) works for traversals as well – it combines
--   traversed values using the (<a>&lt;&gt;</a>) operation (if the values
--   are instances of <a>Monoid</a>).
--   
--   Traversing any value twice is a violation of traversal laws. You can,
--   however, traverse values in any order.
--   
--   Ultimately, traversals should follow 2 laws:
--   
--   <pre>
--   t pure ≡ pure
--   fmap (t f) . t g ≡ getCompose . t (Compose . fmap f . g)
--   </pre>
--   
--   The 1st law states that you can't change the shape of the structure or
--   do anything funny with elements (traverse elements which aren't in the
--   structure, create new elements out of thin air, etc.). The 2nd law
--   states that you should be able to fuse 2 identical traversals into
--   one. For a more detailed explanation of the laws, see <a>this blog
--   post</a> (if you prefer rambling blog posts), or <a>The Essence Of The
--   Iterator Pattern</a> (if you prefer papers).
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | This is a type alias for monomorphic traversals which don't change the
--   type of the container (or of the values inside).
type Traversal' s a = Traversal s s a a

-- | <a>both</a> traverses both fields of a tuple. Unlike
--   <tt><a>both</a></tt> from lens, it only works for pairs – not for
--   triples or <a>Either</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") ^. both
--   "string"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") &amp; both %~ reverse
--   ("rts","gni")
--   </pre>
both :: Traversal (a, a) (b, b) a b

-- | <a>traversed</a> traverses any <a>Traversable</a> container (list,
--   vector, <tt>Map</tt>, <a>Maybe</a>, you name it):
--   
--   <pre>
--   &gt;&gt;&gt; Just 1 ^.. traversed
--   [1]
--   </pre>
--   
--   <a>traversed</a> is the same as <a>traverse</a>, but can be faster
--   thanks to magic rewrite rules.
traversed :: Traversable f => Traversal (f a) (f b) a b

-- | <a>each</a> tries to be a universal <a>Traversal</a> – it behaves like
--   <a>traversed</a> in most situations, but also adds support for e.g.
--   tuples with same-typed values:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; each %~ succ
--   (2,3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ["x", "y", "z"] ^. each
--   "xyz"
--   </pre>
--   
--   However, note that <a>each</a> doesn't work on <i>every</i> instance
--   of <a>Traversable</a>. If you have a <a>Traversable</a> which isn't
--   supported by <a>each</a>, you can use <a>traversed</a> instead.
--   Personally, I like using <a>each</a> instead of <a>traversed</a>
--   whenever possible – it's shorter and more descriptive.
--   
--   You can use <a>each</a> with these things:
--   
--   <pre>
--   <a>each</a> :: <a>Traversal</a> [a] [b] a b
--   
--   <a>each</a> :: <a>Traversal</a> (<a>Maybe</a> a) (<a>Maybe</a> b) a b
--   
--   <a>each</a> :: <a>Traversal</a> (a,a) (b,b) a b
--   <a>each</a> :: <a>Traversal</a> (a,a,a) (b,b,b) a b
--   <a>each</a> :: <a>Traversal</a> (a,a,a,a) (b,b,b,b) a b
--   <a>each</a> :: <a>Traversal</a> (a,a,a,a,a) (b,b,b,b,b) a b
--   
--   <a>each</a> :: (<a>RealFloat</a> a, <a>RealFloat</a> b) =&gt; <a>Traversal</a> (<a>Complex</a> a) (<a>Complex</a> b) a b
--   </pre>
--   
--   Additionally, you can use <a>each</a> with types from <a>array</a>,
--   <a>bytestring</a>, and <a>containers</a> by importing
--   <tt>Lens.Micro.GHC</tt> from the <a>microlens-ghc</a> package.
each :: Each s t a b => Traversal s t a b

-- | This traversal lets you access (and update) an arbitrary element in a
--   list, array, <tt>Map</tt>, etc. (If you want to insert or delete
--   elements as well, look at <a>at</a>.)
--   
--   An example for lists:
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 3 .~ 10
--   [0,1,2,100,4,5]
--   </pre>
--   
--   You can use it for getting, too:
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] ^? ix 3
--   Just 3
--   </pre>
--   
--   Of course, the element may not be present (which means that you can
--   use <a>ix</a> as a safe variant of (<a>!!</a>)):
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] ^? ix 10
--   Nothing
--   </pre>
--   
--   Another useful instance is the one for functions – it lets you modify
--   their outputs for specific inputs. For instance, here's <a>maximum</a>
--   that returns 0 when the list is empty (instead of throwing an
--   exception):
--   
--   <pre>
--   maximum0 = <a>maximum</a> <a>&amp;</a> <a>ix</a> [] <a>.~</a> 0
--   </pre>
--   
--   The following instances are provided in this package:
--   
--   <pre>
--   <a>ix</a> :: <a>Int</a> -&gt; <a>Traversal'</a> [a] a
--   
--   <a>ix</a> :: (<a>Eq</a> e) =&gt; e -&gt; <a>Traversal'</a> (e -&gt; a) a
--   </pre>
--   
--   Additionally, you can use <a>ix</a> with types from <a>array</a>,
--   <a>bytestring</a>, and <a>containers</a> by importing
--   <tt>Lens.Micro.GHC</tt> from the <a>microlens-ghc</a> package.
ix :: Ixed m => Index m -> Traversal' m (IxValue m)

-- | <a>_Left</a> targets the value contained in an <a>Either</a>, provided
--   it's a <a>Left</a>.
--   
--   Gathering all <tt>Left</tt>s in a structure (like the <a>lefts</a>
--   function, but not necessarily just for lists):
--   
--   <pre>
--   &gt;&gt;&gt; [Left 1, Right 'c', Left 3] ^.. each._Just
--   [1,3]
--   </pre>
--   
--   Checking whether an <a>Either</a> is a <a>Left</a> (like
--   <a>isLeft</a>):
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Right 1)
--   False
--   </pre>
--   
--   Extracting a value (if you're sure it's a <a>Left</a>):
--   
--   <pre>
--   &gt;&gt;&gt; Left 1 ^?! _Left
--   1
--   </pre>
--   
--   Mapping over all <a>Left</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; (each._Left %~ map toUpper) [Left "foo", Right "bar"]
--   [Left "FOO",Right "bar"]
--   </pre>
--   
--   Implementation:
--   
--   <pre>
--   <a>_Left</a> f (Left a)  = <a>Left</a> <a>&lt;$&gt;</a> f a
--   <a>_Left</a> _ (Right b) = <a>pure</a> (<a>Right</a> b)
--   </pre>
_Left :: Traversal (Either a b) (Either a' b) a a'

-- | <a>_Right</a> targets the value contained in an <a>Either</a>,
--   provided it's a <a>Right</a>.
--   
--   See documentation for <a>_Left</a>.
_Right :: Traversal (Either a b) (Either a b') b b'

-- | <a>_Just</a> targets the value contained in a <a>Maybe</a>, provided
--   it's a <a>Just</a>.
--   
--   See documentation for <a>_Left</a> (as these 2 are pretty similar). In
--   particular, it can be used to write these:
--   
--   <ul>
--   <li>Unsafely extracting a value from a <a>Just</a>:</li>
--   </ul>
--   
--   <pre>
--   <a>fromJust</a> = (<a>^?!</a> <a>_Just</a>)
--   
--   </pre>
--   
--   <ul>
--   <li>Checking whether a value is a <a>Just</a>:</li>
--   </ul>
--   
--   <pre>
--   <a>isJust</a> = <a>has</a> <a>_Just</a>
--   
--   </pre>
--   
--   <ul>
--   <li>Converting a <a>Maybe</a> to a list (empty or consisting of a
--   single element):</li>
--   </ul>
--   
--   <pre>
--   <a>maybeToList</a> = (<a>^..</a> <a>_Just</a>)
--   
--   </pre>
--   
--   <ul>
--   <li>Gathering all <a>Just</a>s in a list:</li>
--   </ul>
--   
--   <pre>
--   <a>catMaybes</a> = (<a>^..</a> <a>each</a> <a>.</a> <a>_Just</a>)
--   
--   </pre>
_Just :: Traversal (Maybe a) (Maybe a') a a'

-- | <a>_Nothing</a> targets a <tt>()</tt> if the <a>Maybe</a> is a
--   <a>Nothing</a>, and doesn't target anything otherwise:
--   
--   <pre>
--   &gt;&gt;&gt; Just 1 ^.. _Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^.. _Nothing
--   [()]
--   </pre>
--   
--   It's not particularly useful (unless you want to use <tt><a>has</a>
--   <a>_Nothing</a></tt> as a replacement for <a>isNothing</a>), and
--   provided mainly for consistency.
--   
--   Implementation:
--   
--   <pre>
--   <a>_Nothing</a> f Nothing = <a>const</a> <a>Nothing</a> <a>&lt;$&gt;</a> f ()
--   <a>_Nothing</a> _ j       = <a>pure</a> j
--   </pre>
_Nothing :: Traversal' (Maybe a) ()
