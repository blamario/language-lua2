-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic support for list-like structures
--   
--   Generic support for list-like structures in Haskell.
--   
--   The ListLike module provides a common interface to the various Haskell
--   types that are list-like. Predefined interfaces include standard
--   Haskell lists, Arrays, ByteStrings, and lazy ByteStrings. Custom types
--   can easily be made ListLike instances as well.
--   
--   ListLike also provides for String-like types, such as String and
--   ByteString, for types that support input and output, and for types
--   that can handle infinite lists.
@package ListLike
@version 4.2.0


-- | Generic tools for data structures that can be folded.
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.FoldableLL

-- | This is the primary class for structures that are to be considered
--   foldable. A minimum complete definition provides <a>foldl</a> and
--   <a>foldr</a>.
--   
--   Instances of <a>FoldableLL</a> can be folded, and can be many and
--   varied.
--   
--   These functions are used heavily in <a>Data.ListLike</a>.
class FoldableLL full item | full -> item where foldl' f a xs = foldr f' id xs a where f' x k z = k $! f z x foldl1 f xs = fromMaybe (error "fold1: empty structure") (foldl mf Nothing xs) where mf Nothing y = Just y mf (Just x) y = Just (f x y) foldr' f a xs = foldl f' id xs a where f' k x z = k $! f x z foldr1 f xs = fromMaybe (error "foldr1: empty structure") (foldr mf Nothing xs) where mf x Nothing = Just x mf x (Just y) = Just (f x y)

-- | Left-associative fold
foldl :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | Strict version of <a>foldl</a>.
foldl' :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | A variant of <a>foldl</a> with no base case. Requires at least 1 list
--   element.
foldl1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | Right-associative fold
foldr :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Strict version of <a>foldr</a>
foldr' :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Like <a>foldr</a>, but with no starting value
foldr1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | Combine the elements of a structure using a monoid. <tt><a>fold</a> =
--   <a>foldMap</a> id</tt>
fold :: (FoldableLL full item, Monoid item) => full -> item

-- | Map each element to a monoid, then combine the results
foldMap :: (FoldableLL full item, Monoid m) => (item -> m) -> full -> m

-- | Monadic version of left fold, similar to <a>foldM</a>.
foldM :: (Monad m, FoldableLL full item) => (a -> item -> m a) -> a -> full -> m a

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()

-- | A map in monad space, discarding results.
mapM_ :: (Monad m, FoldableLL full item) => (item -> m b) -> full -> m ()
instance Data.ListLike.FoldableLL.FoldableLL [a] a


-- | Generic operations over list-like structures
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.Base

-- | The class implementing list-like functions.
--   
--   It is worth noting that types such as <a>Map</a> can be instances of
--   <a>ListLike</a>. Due to their specific ways of operating, they may not
--   behave in the expected way in some cases. For instance, <a>cons</a>
--   may not increase the size of a map if the key you have given is
--   already in the map; it will just replace the value already there.
--   
--   Implementators must define at least:
--   
--   <ul>
--   <li>singleton</li>
--   <li>head</li>
--   <li>tail</li>
--   <li>null or genericLength</li>
--   </ul>
class (FoldableLL full item, Monoid full) => ListLike full item | full -> item where empty = mempty cons item l = append (singleton item) l snoc l item = append l (singleton item) append = mappend last l = case genericLength l of { (0 :: Integer) -> error "Called last on empty list" 1 -> head l _ -> last (tail l) } init l | null l = error "init: empty list" | null xs = empty | otherwise = cons (head l) (init xs) where xs = tail l null x = genericLength x == (0 :: Integer) length = genericLength map func inp | null inp = empty | otherwise = cons (func (head inp)) (map func (tail inp)) rigidMap = map reverse l = rev l empty where rev rl a | null rl = a | otherwise = rev (tail rl) (cons (head rl) a) intersperse sep l | null l = empty | null xs = singleton x | otherwise = cons x (cons sep (intersperse sep xs)) where x = head l xs = tail l concat = fold concatMap = foldMap rigidConcatMap = concatMap any p = getAny . foldMap (Any . p) all p = getAll . foldMap (All . p) maximum = foldr1 max minimum = foldr1 min replicate = genericReplicate take = genericTake drop = genericDrop splitAt = genericSplitAt takeWhile func l | null l = empty | func x = cons x (takeWhile func (tail l)) | otherwise = empty where x = head l dropWhile func l | null l = empty | func (head l) = dropWhile func (tail l) | otherwise = l dropWhileEnd func = foldr (\ x xs -> if func x && null xs then empty else cons x xs) empty span func l | null l = (empty, empty) | func x = (cons x ys, zs) | otherwise = (empty, l) where (ys, zs) = span func (tail l) x = head l break p = span (not . p) group = groupBy (==) inits l | null l = singleton empty | otherwise = append (singleton empty) (map (cons (head l)) theinits) where theinits = asTypeOf (inits (tail l)) [l] tails l | null l = singleton empty | otherwise = cons l (tails (tail l)) isPrefixOf needle haystack | null needle = True | null haystack = False | otherwise = (head needle) == (head haystack) && isPrefixOf (tail needle) (tail haystack) isSuffixOf needle haystack = isPrefixOf (reverse needle) (reverse haystack) isInfixOf needle haystack = any (isPrefixOf needle) thetails where thetails = asTypeOf (tails haystack) [haystack] elem i = any (== i) notElem i = all (/= i) find f l = case findIndex f l of { Nothing -> Nothing Just x -> Just (index l x) } filter func l | null l = empty | func (head l) = cons (head l) (filter func (tail l)) | otherwise = filter func (tail l) partition p xs = (filter p xs, filter (not . p) xs) index l i | null l = error "index: index not found" | i < 0 = error "index: index must be >= 0" | i == 0 = head l | otherwise = index (tail l) (i - 1) elemIndex e l = findIndex (== e) l elemIndices i l = findIndices (== i) l findIndex f = listToMaybe . findIndices f findIndices p xs = map snd $ filter (p . fst) $ thezips where thezips = asTypeOf (zip xs [0 .. ]) [(head xs, 0 :: Int)] sequence l = foldr func (return empty) l where func litem results = do { x <- litem; xs <- results; return (cons x xs) } mapM func l = sequence mapresult where mapresult = asTypeOf (map func l) [] rigidMapM = mapM nub = nubBy (==) delete = deleteBy (==) deleteFirsts = foldl (flip delete) union = unionBy (==) intersect = intersectBy (==) sort = sortBy compare insert = insertBy compare toList = fromListLike fromList [] = empty fromList (x : xs) = cons x (fromList xs) fromListLike = map id nubBy f l = nubBy' l (empty :: full) where nubBy' ys xs | null ys = empty | any (f (head ys)) xs = nubBy' (tail ys) xs | otherwise = let y = head ys in cons y (nubBy' (tail ys) (cons y xs)) deleteBy func i l | null l = empty | otherwise = if func i (head l) then tail l else cons (head l) (deleteBy func i (tail l)) deleteFirstsBy func = foldl (flip (deleteBy func)) unionBy func x y = append x $ foldl (flip (deleteBy func)) (nubBy func y) x intersectBy func xs ys = filter (\ x -> any (func x) ys) xs groupBy eq l | null l = empty | otherwise = cons (cons x ys) (groupBy eq zs) where (ys, zs) = span (eq x) xs x = head l xs = tail l sortBy cmp = foldr (insertBy cmp) empty insertBy cmp x ys | null ys = singleton x | otherwise = case cmp x (head ys) of { GT -> cons (head ys) (insertBy cmp x (tail ys)) _ -> cons x ys } genericLength l = calclen 0 l where calclen !accum cl = if null cl then accum else calclen (accum + 1) (tail cl) genericTake n l | n <= 0 = empty | null l = empty | otherwise = cons (head l) (genericTake (n - 1) (tail l)) genericDrop n l | n <= 0 = l | null l = l | otherwise = genericDrop (n - 1) (tail l) genericSplitAt n l = (genericTake n l, genericDrop n l) genericReplicate count x | count <= 0 = empty | otherwise = map (\ _ -> x) [1 .. count]

-- | The empty list
empty :: ListLike full item => full

-- | Creates a single-element list out of an element
singleton :: ListLike full item => item -> full

-- | Like (:) for lists: adds an element to the beginning of a list
cons :: ListLike full item => item -> full -> full

-- | Adds an element to the *end* of a <a>ListLike</a>.
snoc :: ListLike full item => full -> item -> full

-- | Combines two lists. Like (++).
append :: ListLike full item => full -> full -> full

-- | Extracts the first element of a <a>ListLike</a>.
head :: ListLike full item => full -> item

-- | Extracts the last element of a <a>ListLike</a>.
last :: ListLike full item => full -> item

-- | Gives all elements after the head.
tail :: ListLike full item => full -> full

-- | All elements of the list except the last one. See also <a>inits</a>.
init :: ListLike full item => full -> full

-- | Tests whether the list is empty.
null :: ListLike full item => full -> Bool

-- | Length of the list. See also <a>genericLength</a>.
length :: ListLike full item => full -> Int

-- | Apply a function to each element, returning any other valid
--   <a>ListLike</a>. <a>rigidMap</a> will always be at least as fast, if
--   not faster, than this function and is recommended if it will work for
--   your purposes. See also <a>mapM</a>.
map :: (ListLike full item, ListLike full' item') => (item -> item') -> full -> full'

-- | Like <a>map</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits for things such as
--   ByteStrings, since it will let the ByteString use its native low-level
--   map implementation.
rigidMap :: ListLike full item => (item -> item) -> full -> full

-- | Reverse the elements in a list.
reverse :: ListLike full item => full -> full

-- | Add an item between each element in the structure
intersperse :: ListLike full item => item -> full -> full

-- | Flatten the structure.
concat :: (ListLike full item, ListLike full' full, Monoid full) => full' -> full

-- | Map a function over the items and concatenate the results. See also
--   <a>rigidConcatMap</a>.
concatMap :: (ListLike full item, ListLike full' item') => (item -> full') -> full -> full'

-- | Like <a>concatMap</a>, but without the possibility of changing the
--   type of the item. This can have performance benefits for some things
--   such as ByteString.
rigidConcatMap :: ListLike full item => (item -> full) -> full -> full

-- | True if any items satisfy the function
any :: ListLike full item => (item -> Bool) -> full -> Bool

-- | True if all items satisfy the function
all :: ListLike full item => (item -> Bool) -> full -> Bool

-- | The maximum value of the list
maximum :: (ListLike full item, Ord item) => full -> item

-- | The minimum value of the list
minimum :: (ListLike full item, Ord item) => full -> item

-- | Generate a structure with the specified length with every element set
--   to the item passed in. See also <a>genericReplicate</a>
replicate :: ListLike full item => Int -> item -> full

-- | Takes the first n elements of the list. See also <a>genericTake</a>.
take :: ListLike full item => Int -> full -> full

-- | Drops the first n elements of the list. See also <a>genericDrop</a>
drop :: ListLike full item => Int -> full -> full

-- | Equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>. See also
--   <a>genericSplitAt</a>.
splitAt :: ListLike full item => Int -> full -> (full, full)

-- | Returns all elements at start of list that satisfy the function.
takeWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the start of the list that satisfy the
--   function.
dropWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the end of the list that satisfy the function.
dropWhileEnd :: ListLike full item => (item -> Bool) -> full -> full

-- | The equivalent of <tt>(<a>takeWhile</a> f xs, <a>dropWhile</a> f
--   xs)</tt>
span :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The equivalent of <tt><a>span</a> (<a>not</a> . f)</tt>
break :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | Split a list into sublists, each which contains equal arguments. For
--   order-preserving types, concatenating these sublists will produce the
--   original list. See also <a>groupBy</a>.
group :: (ListLike full item, ListLike full' full, Eq item) => full -> full'

-- | All initial segments of the list, shortest first
inits :: (ListLike full item, ListLike full' full) => full -> full'

-- | All final segnemts, longest first
tails :: (ListLike full item, ListLike full' full) => full -> full'

-- | True when the first list is at the beginning of the second.
isPrefixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is at the beginning of the second.
isSuffixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is wholly containted within the second
isInfixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True if the item occurs in the list
elem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | True if the item does not occur in the list
notElem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | Take a function and return the first matching element, or Nothing if
--   there is no such element.
find :: ListLike full item => (item -> Bool) -> full -> Maybe item

-- | Returns only the elements that satisfy the function.
filter :: ListLike full item => (item -> Bool) -> full -> full

-- | Returns the lists that do and do not satisfy the function. Same as
--   <tt>(<a>filter</a> p xs, <a>filter</a> (<a>not</a> . p) xs)</tt>
partition :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The element at 0-based index i. Raises an exception if i is out of
--   bounds. Like (!!) for lists.
index :: ListLike full item => full -> Int -> item

-- | Returns the index of the element, if it exists.
elemIndex :: (ListLike full item, Eq item) => item -> full -> Maybe Int

-- | Returns the indices of the matching elements. See also
--   <a>findIndices</a>
elemIndices :: (ListLike full item, Eq item, ListLike result Int) => item -> full -> result

-- | Take a function and return the index of the first matching element, or
--   Nothing if no element matches
findIndex :: ListLike full item => (item -> Bool) -> full -> Maybe Int

-- | Returns the indices of all elements satisfying the function
findIndices :: (ListLike full item, ListLike result Int) => (item -> Bool) -> full -> result

-- | Evaluate each action in the sequence and collect the results
sequence :: (ListLike full item, Monad m, ListLike fullinp (m item)) => fullinp -> m full

-- | A map in monad space. Same as <tt><a>sequence</a> . <a>map</a></tt>
--   
--   See also <a>rigidMapM</a>
mapM :: (ListLike full item, Monad m, ListLike full' item') => (item -> m item') -> full -> m full'

-- | Like <a>mapM</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits with some types.
rigidMapM :: (ListLike full item, Monad m) => (item -> m item) -> full -> m full

-- | Removes duplicate elements from the list. See also <a>nubBy</a>
nub :: (ListLike full item, Eq item) => full -> full

-- | Removes the first instance of the element from the list. See also
--   <a>deleteBy</a>
delete :: (ListLike full item, Eq item) => item -> full -> full

-- | List difference. Removes from the first list the first instance of
--   each element of the second list. See '(\)' and <a>deleteFirstsBy</a>
deleteFirsts :: (ListLike full item, Eq item) => full -> full -> full

-- | List union: the set of elements that occur in either list. Duplicate
--   elements in the first list will remain duplicate. See also
--   <a>unionBy</a>.
union :: (ListLike full item, Eq item) => full -> full -> full

-- | List intersection: the set of elements that occur in both lists. See
--   also <a>intersectBy</a>
intersect :: (ListLike full item, Eq item) => full -> full -> full

-- | Sorts the list. On data types that do not preserve ordering, or
--   enforce their own ordering, the result may not be what you expect. See
--   also <a>sortBy</a>.
sort :: (ListLike full item, Ord item) => full -> full

-- | Inserts the element at the last place where it is still less than or
--   equal to the next element. On data types that do not preserve
--   ordering, or enforce their own ordering, the result may not be what
--   you expect. On types such as maps, this may result in changing an
--   existing item. See also <a>insertBy</a>.
insert :: (ListLike full item, Ord item) => item -> full -> full

-- | Converts the structure to a list. This is logically equivolent to
--   <a>fromListLike</a>, but may have a more optimized implementation.
toList :: ListLike full item => full -> [item]

-- | Generates the structure from a list.
fromList :: ListLike full item => [item] -> full

-- | Converts one ListLike to another. See also <a>toList</a>. Default
--   implementation is <tt>fromListLike = map id</tt>
fromListLike :: (ListLike full item, ListLike full' item) => full -> full'

-- | Generic version of <a>nub</a>
nubBy :: ListLike full item => (item -> item -> Bool) -> full -> full

-- | Generic version of <a>deleteBy</a>
deleteBy :: ListLike full item => (item -> item -> Bool) -> item -> full -> full

-- | Generic version of <a>deleteFirsts</a>
deleteFirstsBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>union</a>
unionBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>intersect</a>
intersectBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>group</a>.
groupBy :: (ListLike full item, ListLike full' full, Eq item) => (item -> item -> Bool) -> full -> full'

-- | Sort function taking a custom comparison function
sortBy :: ListLike full item => (item -> item -> Ordering) -> full -> full

-- | Like <a>insert</a>, but with a custom comparison function
insertBy :: ListLike full item => (item -> item -> Ordering) -> item -> full -> full

-- | Length of the list
genericLength :: (ListLike full item, Num a) => full -> a

-- | Generic version of <a>take</a>
genericTake :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>drop</a>
genericDrop :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>splitAt</a>
genericSplitAt :: (ListLike full item, Integral a) => a -> full -> (full, full)

-- | Generic version of <a>replicate</a>
genericReplicate :: (ListLike full item, Integral a) => a -> item -> full

-- | An extension to <a>ListLike</a> for those data types that are capable
--   of dealing with infinite lists. Some <a>ListLike</a> functions are
--   capable of working with finite or infinite lists. The functions here
--   require infinite list capability in order to work at all.
class (ListLike full item) => InfiniteListLike full item | full -> item where iterate f x = cons x (iterate f (f x)) repeat x = xs where xs = cons x xs cycle xs | null xs = error "ListLike.cycle: empty list" | otherwise = xs' where xs' = append xs xs'

-- | An infinite list of repeated calls of the function to args
iterate :: InfiniteListLike full item => (item -> item) -> item -> full

-- | An infinite list where each element is the same
repeat :: InfiniteListLike full item => item -> full

-- | Converts a finite list into a circular one
cycle :: InfiniteListLike full item => full -> full

-- | Takes two lists and returns a list of corresponding pairs.
zip :: (ListLike full item, ListLike fullb itemb, ListLike result (item, itemb)) => full -> fullb -> result

-- | Takes two lists and combines them with a custom combining function
zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()
instance Data.ListLike.Base.ListLike [a] a


-- | String-like functions
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.String

-- | An extension to <a>ListLike</a> for those data types that are similar
--   to a <a>String</a>. Minimal complete definition is <a>toString</a> and
--   <a>fromString</a>.
class StringLike s where lines = myLines words = myWords unlines = myUnlines unwords = myUnwords

-- | Converts the structure to a <a>String</a>
toString :: StringLike s => s -> String

-- | Converts a <a>String</a> to a list
fromString :: StringLike s => String -> s

-- | Breaks a string into a list of strings
lines :: (StringLike s, ListLike full s) => s -> full

-- | Breaks a string into a list of words
words :: (StringLike s, ListLike full s) => s -> full

-- | Joins lines
unlines :: (StringLike s, ListLike full s) => full -> s

-- | Joins words
unwords :: (StringLike s, ListLike full s) => full -> s


-- | Utilities for <a>ListLike</a> and friends. More functions similar to
--   <a>List</a> but not part of the main typeclass.
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.Utils

-- | Returns True if all elements are True
and :: ListLike full Bool => full -> Bool

-- | Returns True if any element is True
or :: ListLike full Bool => full -> Bool

-- | The sum of the list
sum :: (Num a, ListLike full a) => full -> a

-- | The product of the list
product :: (Num a, ListLike full a) => full -> a

-- | Takes two lists and returns a list of corresponding pairs.
zip :: (ListLike full item, ListLike fullb itemb, ListLike result (item, itemb)) => full -> fullb -> result

-- | Takes two lists and combines them with a custom combining function
zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result

-- | Converts a list of pairs into two separate lists of elements
unzip :: (ListLike full (itema, itemb), ListLike ra itema, ListLike rb itemb) => full -> (ra, rb)

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()

-- | Converts to a MonadPlus instance
toMonadPlus :: (MonadPlus m, ListLike full a) => full -> m (a, full)

-- | List-like destructor (like Data.Maybe.maybe)
list :: ListLike full a => b -> (a -> full -> b) -> full -> b


-- | String-like functions
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.IO

-- | An extension to <a>ListLike</a> for those data types that support I/O.
--   These functions mirror those in <a>System.IO</a> for the most part.
--   They also share the same names; see the comments in
--   <a>Data.ListLike</a> for help importing them.
--   
--   Note that some types may not be capable of lazy reading or writing.
--   Therefore, the usual semantics of <a>System.IO</a> functions regarding
--   laziness may or may not be available from a particular implementation.
--   
--   Minimal complete definition:
--   
--   <ul>
--   <li>hGetLine</li>
--   <li>hGetContents</li>
--   <li>hGet</li>
--   <li>hGetNonBlocking</li>
--   <li>hPutStr</li>
--   </ul>
class (ListLike full item) => ListLikeIO full item | full -> item where hPutStrLn fp x = do { hPutStr fp x; hPutStrLn fp "" } getLine = hGetLine stdin getContents = hGetContents stdin putStr = hPutStr stdout putStrLn = hPutStrLn stdout interact func = do { c <- getContents; putStr (func c) } readFile fn = do { fp <- openFile fn ReadMode; hGetContents fp } writeFile fn x = do { fp <- openFile fn WriteMode; hPutStr fp x; hClose fp } appendFile fn x = do { fp <- openFile fn AppendMode; hPutStr fp x; hClose fp }

-- | Reads a line from the specified handle
hGetLine :: ListLikeIO full item => Handle -> IO full

-- | Read entire handle contents. May be done lazily like
--   <a>hGetContents</a>.
hGetContents :: ListLikeIO full item => Handle -> IO full

-- | Read specified number of bytes. See <a>hGet</a> for particular
--   semantics.
hGet :: ListLikeIO full item => Handle -> Int -> IO full

-- | Non-blocking read. See <a>hGetNonBlocking</a> for more.
hGetNonBlocking :: ListLikeIO full item => Handle -> Int -> IO full

-- | Writing entire data.
hPutStr :: ListLikeIO full item => Handle -> full -> IO ()

-- | Write data plus newline character.
hPutStrLn :: ListLikeIO full item => Handle -> full -> IO ()

-- | Read one line
getLine :: ListLikeIO full item => IO full

-- | Read entire content from stdin. See <a>hGetContents</a>.
getContents :: ListLikeIO full item => IO full

-- | Write data to stdout.
putStr :: ListLikeIO full item => full -> IO ()

-- | Write data plus newline character to stdout.
putStrLn :: ListLikeIO full item => full -> IO ()

-- | Interact with stdin and stdout by using a function to transform input
--   to output. May be lazy. See <a>interact</a> for more.
interact :: ListLikeIO full item => (full -> full) -> IO ()

-- | Read file. May be lazy.
readFile :: ListLikeIO full item => FilePath -> IO full

-- | Write data to file.
writeFile :: ListLikeIO full item => FilePath -> full -> IO ()

-- | Append data to file.
appendFile :: ListLikeIO full item => FilePath -> full -> IO ()


-- | Newtype wrapper for ByteString to enable a Char-based interface
--   Re-exported by <a>Data.ListLike</a>.
--   
--   Written by John Lato, jwlato@gmail.com
module Data.ListLike.CharString

-- | Newtype wrapper around Data.ByteString.Char8.ByteString, this allows
--   for ListLike instances with Char elements.
newtype CharString
CS :: ByteString -> CharString
[unCS] :: CharString -> ByteString

-- | Newtype wrapper around Data.ByteString.Lazy.Char8.ByteString, this
--   allows for ListLike instances with Char elements.
newtype CharStringLazy
CSL :: ByteString -> CharStringLazy
[unCSL] :: CharStringLazy -> ByteString
instance GHC.Classes.Ord Data.ListLike.CharString.CharStringLazy
instance GHC.Classes.Eq Data.ListLike.CharString.CharStringLazy
instance GHC.Show.Show Data.ListLike.CharString.CharStringLazy
instance GHC.Read.Read Data.ListLike.CharString.CharStringLazy
instance GHC.Classes.Ord Data.ListLike.CharString.CharString
instance GHC.Classes.Eq Data.ListLike.CharString.CharString
instance GHC.Show.Show Data.ListLike.CharString.CharString
instance GHC.Read.Read Data.ListLike.CharString.CharString
instance GHC.Base.Monoid Data.ListLike.CharString.CharString
instance Data.ListLike.FoldableLL.FoldableLL Data.ListLike.CharString.CharString GHC.Types.Char
instance Data.ListLike.Base.ListLike Data.ListLike.CharString.CharString GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.ListLike.CharString.CharString GHC.Types.Char
instance Data.ListLike.String.StringLike Data.ListLike.CharString.CharString
instance GHC.Base.Monoid Data.ListLike.CharString.CharStringLazy
instance Data.ListLike.FoldableLL.FoldableLL Data.ListLike.CharString.CharStringLazy GHC.Types.Char
instance Data.ListLike.Base.ListLike Data.ListLike.CharString.CharStringLazy GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.ListLike.CharString.CharStringLazy GHC.Types.Char
instance Data.ListLike.String.StringLike Data.ListLike.CharString.CharStringLazy


-- | <a>ListLike</a> instances for <a>DList</a>
module Data.ListLike.DList
instance Data.ListLike.FoldableLL.FoldableLL (Data.DList.DList a) a
instance Data.ListLike.Base.ListLike (Data.DList.DList a) a
instance Data.ListLike.String.StringLike (Data.DList.DList GHC.Types.Char)


-- | <a>ListLike</a> instances for <a>FMList</a>
module Data.ListLike.FMList
instance Data.ListLike.FoldableLL.FoldableLL (Data.FMList.FMList a) a
instance Data.ListLike.Base.ListLike (Data.FMList.FMList a) a
instance Data.ListLike.Base.InfiniteListLike (Data.FMList.FMList a) a
instance Data.String.IsString (Data.FMList.FMList GHC.Types.Char)
instance Data.ListLike.String.StringLike (Data.FMList.FMList GHC.Types.Char)
instance Control.Monad.Zip.MonadZip Data.FMList.FMList

module Data.ListLike.Text.Text
instance Data.ListLike.FoldableLL.FoldableLL Data.Text.Internal.Text GHC.Types.Char
instance Data.ListLike.Base.ListLike Data.Text.Internal.Text GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.Text.Internal.Text GHC.Types.Char
instance Data.ListLike.String.StringLike Data.Text.Internal.Text

module Data.ListLike.Text.TextLazy
instance Data.ListLike.FoldableLL.FoldableLL Data.Text.Internal.Lazy.Text GHC.Types.Char
instance Data.ListLike.Base.ListLike Data.Text.Internal.Lazy.Text GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.Text.Internal.Lazy.Text GHC.Types.Char
instance Data.ListLike.String.StringLike Data.Text.Internal.Lazy.Text

module Data.ListLike.Text

module Data.ListLike.Vector.Storable
instance Foreign.Storable.Storable a => Data.ListLike.FoldableLL.FoldableLL (Data.Vector.Storable.Vector a) a
instance Foreign.Storable.Storable a => Data.ListLike.Base.ListLike (Data.Vector.Storable.Vector a) a
instance Data.ListLike.String.StringLike (Data.Vector.Storable.Vector GHC.Types.Char)

module Data.ListLike.Vector.Unboxed
instance Data.Vector.Unboxed.Base.Unbox a => Data.ListLike.FoldableLL.FoldableLL (Data.Vector.Unboxed.Base.Vector a) a
instance Data.Vector.Unboxed.Base.Unbox a => Data.ListLike.Base.ListLike (Data.Vector.Unboxed.Base.Vector a) a
instance Data.ListLike.String.StringLike (Data.Vector.Unboxed.Base.Vector GHC.Types.Char)

module Data.ListLike.Vector.Vector
instance Data.ListLike.FoldableLL.FoldableLL (Data.Vector.Vector a) a
instance Data.ListLike.Base.ListLike (Data.Vector.Vector a) a
instance Data.ListLike.String.StringLike (Data.Vector.Vector GHC.Types.Char)


-- | <a>ListLike</a> instances for several <tt>Data.Vector</tt> types. The
--   <tt>Data.ListLike.Vector.Generic</tt> instances are not exported from
--   this module in order to prevent collisions.
module Data.ListLike.Vector


-- | Instances of <a>ListLike</a> and related classes. Re-exported by
--   <a>Data.ListLike</a>.
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.Instances
instance Data.ListLike.IO.ListLikeIO GHC.Base.String GHC.Types.Char
instance Data.ListLike.String.StringLike GHC.Base.String
instance Data.ListLike.Base.InfiniteListLike [a] a
instance Data.ListLike.FoldableLL.FoldableLL Data.ByteString.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.Base.ListLike Data.ByteString.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.IO.ListLikeIO Data.ByteString.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.String.StringLike Data.ByteString.Internal.ByteString
instance Data.ListLike.FoldableLL.FoldableLL Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.Base.ListLike Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.IO.ListLikeIO Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.String.StringLike Data.ByteString.Lazy.Internal.ByteString
instance GHC.Arr.Ix i => Data.ListLike.FoldableLL.FoldableLL (GHC.Arr.Array i e) e
instance (GHC.Real.Integral i, GHC.Arr.Ix i) => GHC.Base.Monoid (GHC.Arr.Array i e)
instance (GHC.Real.Integral i, GHC.Arr.Ix i) => Data.ListLike.Base.ListLike (GHC.Arr.Array i e) e
instance (GHC.Real.Integral i, GHC.Arr.Ix i) => Data.ListLike.String.StringLike (GHC.Arr.Array i GHC.Types.Char)
instance (GHC.Real.Integral i, GHC.Arr.Ix i) => Data.ListLike.IO.ListLikeIO (GHC.Arr.Array i GHC.Types.Char) GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO (Data.Sequence.Seq GHC.Types.Char) GHC.Types.Char
instance Data.ListLike.String.StringLike (Data.Sequence.Seq GHC.Types.Char)
instance Data.ListLike.FoldableLL.FoldableLL (Data.Sequence.Seq a) a
instance Data.ListLike.Base.ListLike (Data.Sequence.Seq a) a


-- | ListLike instance for any type supporting the
--   <tt>Data.Vector.Generic</tt> interface. To avoid collisions with other
--   Vector instances, this module must be imported directly.
module Data.ListLike.Vector.Generic
instance Data.Vector.Generic.Base.Vector v a => Data.ListLike.FoldableLL.FoldableLL (v a) a
instance (GHC.Base.Monoid (v a), GHC.Classes.Eq (v a), Data.Vector.Generic.Base.Vector v a) => Data.ListLike.Base.ListLike (v a) a
instance (GHC.Classes.Eq (v GHC.Types.Char), Data.Vector.Generic.Base.Vector v GHC.Types.Char) => Data.ListLike.String.StringLike (v GHC.Types.Char)


-- | Generic operations over list-like structures
--   
--   Written by John Goerzen, jgoerzen@complete.org
--   
--   Please start with the introduction at <a>Data.ListLike#intro</a>.
module Data.ListLike

-- | Returns True if all elements are True
and :: ListLike full Bool => full -> Bool

-- | Returns True if any element is True
or :: ListLike full Bool => full -> Bool

-- | The sum of the list
sum :: (Num a, ListLike full a) => full -> a

-- | The product of the list
product :: (Num a, ListLike full a) => full -> a

-- | Combine the elements of a structure using a monoid. <tt><a>fold</a> =
--   <a>foldMap</a> id</tt>
fold :: (FoldableLL full item, Monoid item) => full -> item

-- | Map each element to a monoid, then combine the results
foldMap :: (FoldableLL full item, Monoid m) => (item -> m) -> full -> m

-- | Takes two lists and returns a list of corresponding pairs.
zip :: (ListLike full item, ListLike fullb itemb, ListLike result (item, itemb)) => full -> fullb -> result

-- | Takes two lists and combines them with a custom combining function
zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result

-- | Converts a list of pairs into two separate lists of elements
unzip :: (ListLike full (itema, itemb), ListLike ra itema, ListLike rb itemb) => full -> (ra, rb)

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()

-- | A map in monad space, discarding results.
mapM_ :: (Monad m, FoldableLL full item) => (item -> m b) -> full -> m ()

-- | An extension to <a>ListLike</a> for those data types that support I/O.
--   These functions mirror those in <a>System.IO</a> for the most part.
--   They also share the same names; see the comments in
--   <a>Data.ListLike</a> for help importing them.
--   
--   Note that some types may not be capable of lazy reading or writing.
--   Therefore, the usual semantics of <a>System.IO</a> functions regarding
--   laziness may or may not be available from a particular implementation.
--   
--   Minimal complete definition:
--   
--   <ul>
--   <li>hGetLine</li>
--   <li>hGetContents</li>
--   <li>hGet</li>
--   <li>hGetNonBlocking</li>
--   <li>hPutStr</li>
--   </ul>
class (ListLike full item) => ListLikeIO full item | full -> item where hPutStrLn fp x = do { hPutStr fp x; hPutStrLn fp "" } getLine = hGetLine stdin getContents = hGetContents stdin putStr = hPutStr stdout putStrLn = hPutStrLn stdout interact func = do { c <- getContents; putStr (func c) } readFile fn = do { fp <- openFile fn ReadMode; hGetContents fp } writeFile fn x = do { fp <- openFile fn WriteMode; hPutStr fp x; hClose fp } appendFile fn x = do { fp <- openFile fn AppendMode; hPutStr fp x; hClose fp }

-- | Reads a line from the specified handle
hGetLine :: ListLikeIO full item => Handle -> IO full

-- | Read entire handle contents. May be done lazily like
--   <a>hGetContents</a>.
hGetContents :: ListLikeIO full item => Handle -> IO full

-- | Read specified number of bytes. See <a>hGet</a> for particular
--   semantics.
hGet :: ListLikeIO full item => Handle -> Int -> IO full

-- | Non-blocking read. See <a>hGetNonBlocking</a> for more.
hGetNonBlocking :: ListLikeIO full item => Handle -> Int -> IO full

-- | Writing entire data.
hPutStr :: ListLikeIO full item => Handle -> full -> IO ()

-- | Write data plus newline character.
hPutStrLn :: ListLikeIO full item => Handle -> full -> IO ()

-- | Read one line
getLine :: ListLikeIO full item => IO full

-- | Read entire content from stdin. See <a>hGetContents</a>.
getContents :: ListLikeIO full item => IO full

-- | Write data to stdout.
putStr :: ListLikeIO full item => full -> IO ()

-- | Write data plus newline character to stdout.
putStrLn :: ListLikeIO full item => full -> IO ()

-- | Interact with stdin and stdout by using a function to transform input
--   to output. May be lazy. See <a>interact</a> for more.
interact :: ListLikeIO full item => (full -> full) -> IO ()

-- | Read file. May be lazy.
readFile :: ListLikeIO full item => FilePath -> IO full

-- | Write data to file.
writeFile :: ListLikeIO full item => FilePath -> full -> IO ()

-- | Append data to file.
appendFile :: ListLikeIO full item => FilePath -> full -> IO ()

-- | Newtype wrapper around Data.ByteString.Char8.ByteString, this allows
--   for ListLike instances with Char elements.
newtype CharString
CS :: ByteString -> CharString
[unCS] :: CharString -> ByteString

-- | Newtype wrapper around Data.ByteString.Lazy.Char8.ByteString, this
--   allows for ListLike instances with Char elements.
newtype CharStringLazy
CSL :: ByteString -> CharStringLazy
[unCSL] :: CharStringLazy -> ByteString

-- | The class implementing list-like functions.
--   
--   It is worth noting that types such as <a>Map</a> can be instances of
--   <a>ListLike</a>. Due to their specific ways of operating, they may not
--   behave in the expected way in some cases. For instance, <a>cons</a>
--   may not increase the size of a map if the key you have given is
--   already in the map; it will just replace the value already there.
--   
--   Implementators must define at least:
--   
--   <ul>
--   <li>singleton</li>
--   <li>head</li>
--   <li>tail</li>
--   <li>null or genericLength</li>
--   </ul>
class (FoldableLL full item, Monoid full) => ListLike full item | full -> item where empty = mempty cons item l = append (singleton item) l snoc l item = append l (singleton item) append = mappend last l = case genericLength l of { (0 :: Integer) -> error "Called last on empty list" 1 -> head l _ -> last (tail l) } init l | null l = error "init: empty list" | null xs = empty | otherwise = cons (head l) (init xs) where xs = tail l null x = genericLength x == (0 :: Integer) length = genericLength map func inp | null inp = empty | otherwise = cons (func (head inp)) (map func (tail inp)) rigidMap = map reverse l = rev l empty where rev rl a | null rl = a | otherwise = rev (tail rl) (cons (head rl) a) intersperse sep l | null l = empty | null xs = singleton x | otherwise = cons x (cons sep (intersperse sep xs)) where x = head l xs = tail l concat = fold concatMap = foldMap rigidConcatMap = concatMap any p = getAny . foldMap (Any . p) all p = getAll . foldMap (All . p) maximum = foldr1 max minimum = foldr1 min replicate = genericReplicate take = genericTake drop = genericDrop splitAt = genericSplitAt takeWhile func l | null l = empty | func x = cons x (takeWhile func (tail l)) | otherwise = empty where x = head l dropWhile func l | null l = empty | func (head l) = dropWhile func (tail l) | otherwise = l dropWhileEnd func = foldr (\ x xs -> if func x && null xs then empty else cons x xs) empty span func l | null l = (empty, empty) | func x = (cons x ys, zs) | otherwise = (empty, l) where (ys, zs) = span func (tail l) x = head l break p = span (not . p) group = groupBy (==) inits l | null l = singleton empty | otherwise = append (singleton empty) (map (cons (head l)) theinits) where theinits = asTypeOf (inits (tail l)) [l] tails l | null l = singleton empty | otherwise = cons l (tails (tail l)) isPrefixOf needle haystack | null needle = True | null haystack = False | otherwise = (head needle) == (head haystack) && isPrefixOf (tail needle) (tail haystack) isSuffixOf needle haystack = isPrefixOf (reverse needle) (reverse haystack) isInfixOf needle haystack = any (isPrefixOf needle) thetails where thetails = asTypeOf (tails haystack) [haystack] elem i = any (== i) notElem i = all (/= i) find f l = case findIndex f l of { Nothing -> Nothing Just x -> Just (index l x) } filter func l | null l = empty | func (head l) = cons (head l) (filter func (tail l)) | otherwise = filter func (tail l) partition p xs = (filter p xs, filter (not . p) xs) index l i | null l = error "index: index not found" | i < 0 = error "index: index must be >= 0" | i == 0 = head l | otherwise = index (tail l) (i - 1) elemIndex e l = findIndex (== e) l elemIndices i l = findIndices (== i) l findIndex f = listToMaybe . findIndices f findIndices p xs = map snd $ filter (p . fst) $ thezips where thezips = asTypeOf (zip xs [0 .. ]) [(head xs, 0 :: Int)] sequence l = foldr func (return empty) l where func litem results = do { x <- litem; xs <- results; return (cons x xs) } mapM func l = sequence mapresult where mapresult = asTypeOf (map func l) [] rigidMapM = mapM nub = nubBy (==) delete = deleteBy (==) deleteFirsts = foldl (flip delete) union = unionBy (==) intersect = intersectBy (==) sort = sortBy compare insert = insertBy compare toList = fromListLike fromList [] = empty fromList (x : xs) = cons x (fromList xs) fromListLike = map id nubBy f l = nubBy' l (empty :: full) where nubBy' ys xs | null ys = empty | any (f (head ys)) xs = nubBy' (tail ys) xs | otherwise = let y = head ys in cons y (nubBy' (tail ys) (cons y xs)) deleteBy func i l | null l = empty | otherwise = if func i (head l) then tail l else cons (head l) (deleteBy func i (tail l)) deleteFirstsBy func = foldl (flip (deleteBy func)) unionBy func x y = append x $ foldl (flip (deleteBy func)) (nubBy func y) x intersectBy func xs ys = filter (\ x -> any (func x) ys) xs groupBy eq l | null l = empty | otherwise = cons (cons x ys) (groupBy eq zs) where (ys, zs) = span (eq x) xs x = head l xs = tail l sortBy cmp = foldr (insertBy cmp) empty insertBy cmp x ys | null ys = singleton x | otherwise = case cmp x (head ys) of { GT -> cons (head ys) (insertBy cmp x (tail ys)) _ -> cons x ys } genericLength l = calclen 0 l where calclen !accum cl = if null cl then accum else calclen (accum + 1) (tail cl) genericTake n l | n <= 0 = empty | null l = empty | otherwise = cons (head l) (genericTake (n - 1) (tail l)) genericDrop n l | n <= 0 = l | null l = l | otherwise = genericDrop (n - 1) (tail l) genericSplitAt n l = (genericTake n l, genericDrop n l) genericReplicate count x | count <= 0 = empty | otherwise = map (\ _ -> x) [1 .. count]

-- | The empty list
empty :: ListLike full item => full

-- | Creates a single-element list out of an element
singleton :: ListLike full item => item -> full

-- | Like (:) for lists: adds an element to the beginning of a list
cons :: ListLike full item => item -> full -> full

-- | Adds an element to the *end* of a <a>ListLike</a>.
snoc :: ListLike full item => full -> item -> full

-- | Combines two lists. Like (++).
append :: ListLike full item => full -> full -> full

-- | Extracts the first element of a <a>ListLike</a>.
head :: ListLike full item => full -> item

-- | Extracts the last element of a <a>ListLike</a>.
last :: ListLike full item => full -> item

-- | Gives all elements after the head.
tail :: ListLike full item => full -> full

-- | All elements of the list except the last one. See also <a>inits</a>.
init :: ListLike full item => full -> full

-- | Tests whether the list is empty.
null :: ListLike full item => full -> Bool

-- | Length of the list. See also <a>genericLength</a>.
length :: ListLike full item => full -> Int

-- | Apply a function to each element, returning any other valid
--   <a>ListLike</a>. <a>rigidMap</a> will always be at least as fast, if
--   not faster, than this function and is recommended if it will work for
--   your purposes. See also <a>mapM</a>.
map :: (ListLike full item, ListLike full' item') => (item -> item') -> full -> full'

-- | Like <a>map</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits for things such as
--   ByteStrings, since it will let the ByteString use its native low-level
--   map implementation.
rigidMap :: ListLike full item => (item -> item) -> full -> full

-- | Reverse the elements in a list.
reverse :: ListLike full item => full -> full

-- | Add an item between each element in the structure
intersperse :: ListLike full item => item -> full -> full

-- | Flatten the structure.
concat :: (ListLike full item, ListLike full' full, Monoid full) => full' -> full

-- | Map a function over the items and concatenate the results. See also
--   <a>rigidConcatMap</a>.
concatMap :: (ListLike full item, ListLike full' item') => (item -> full') -> full -> full'

-- | Like <a>concatMap</a>, but without the possibility of changing the
--   type of the item. This can have performance benefits for some things
--   such as ByteString.
rigidConcatMap :: ListLike full item => (item -> full) -> full -> full

-- | True if any items satisfy the function
any :: ListLike full item => (item -> Bool) -> full -> Bool

-- | True if all items satisfy the function
all :: ListLike full item => (item -> Bool) -> full -> Bool

-- | The maximum value of the list
maximum :: (ListLike full item, Ord item) => full -> item

-- | The minimum value of the list
minimum :: (ListLike full item, Ord item) => full -> item

-- | Generate a structure with the specified length with every element set
--   to the item passed in. See also <a>genericReplicate</a>
replicate :: ListLike full item => Int -> item -> full

-- | Takes the first n elements of the list. See also <a>genericTake</a>.
take :: ListLike full item => Int -> full -> full

-- | Drops the first n elements of the list. See also <a>genericDrop</a>
drop :: ListLike full item => Int -> full -> full

-- | Equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>. See also
--   <a>genericSplitAt</a>.
splitAt :: ListLike full item => Int -> full -> (full, full)

-- | Returns all elements at start of list that satisfy the function.
takeWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the start of the list that satisfy the
--   function.
dropWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the end of the list that satisfy the function.
dropWhileEnd :: ListLike full item => (item -> Bool) -> full -> full

-- | The equivalent of <tt>(<a>takeWhile</a> f xs, <a>dropWhile</a> f
--   xs)</tt>
span :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The equivalent of <tt><a>span</a> (<a>not</a> . f)</tt>
break :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | Split a list into sublists, each which contains equal arguments. For
--   order-preserving types, concatenating these sublists will produce the
--   original list. See also <a>groupBy</a>.
group :: (ListLike full item, ListLike full' full, Eq item) => full -> full'

-- | All initial segments of the list, shortest first
inits :: (ListLike full item, ListLike full' full) => full -> full'

-- | All final segnemts, longest first
tails :: (ListLike full item, ListLike full' full) => full -> full'

-- | True when the first list is at the beginning of the second.
isPrefixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is at the beginning of the second.
isSuffixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is wholly containted within the second
isInfixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True if the item occurs in the list
elem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | True if the item does not occur in the list
notElem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | Take a function and return the first matching element, or Nothing if
--   there is no such element.
find :: ListLike full item => (item -> Bool) -> full -> Maybe item

-- | Returns only the elements that satisfy the function.
filter :: ListLike full item => (item -> Bool) -> full -> full

-- | Returns the lists that do and do not satisfy the function. Same as
--   <tt>(<a>filter</a> p xs, <a>filter</a> (<a>not</a> . p) xs)</tt>
partition :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The element at 0-based index i. Raises an exception if i is out of
--   bounds. Like (!!) for lists.
index :: ListLike full item => full -> Int -> item

-- | Returns the index of the element, if it exists.
elemIndex :: (ListLike full item, Eq item) => item -> full -> Maybe Int

-- | Returns the indices of the matching elements. See also
--   <a>findIndices</a>
elemIndices :: (ListLike full item, Eq item, ListLike result Int) => item -> full -> result

-- | Take a function and return the index of the first matching element, or
--   Nothing if no element matches
findIndex :: ListLike full item => (item -> Bool) -> full -> Maybe Int

-- | Returns the indices of all elements satisfying the function
findIndices :: (ListLike full item, ListLike result Int) => (item -> Bool) -> full -> result

-- | Evaluate each action in the sequence and collect the results
sequence :: (ListLike full item, Monad m, ListLike fullinp (m item)) => fullinp -> m full

-- | A map in monad space. Same as <tt><a>sequence</a> . <a>map</a></tt>
--   
--   See also <a>rigidMapM</a>
mapM :: (ListLike full item, Monad m, ListLike full' item') => (item -> m item') -> full -> m full'

-- | Like <a>mapM</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits with some types.
rigidMapM :: (ListLike full item, Monad m) => (item -> m item) -> full -> m full

-- | Removes duplicate elements from the list. See also <a>nubBy</a>
nub :: (ListLike full item, Eq item) => full -> full

-- | Removes the first instance of the element from the list. See also
--   <a>deleteBy</a>
delete :: (ListLike full item, Eq item) => item -> full -> full

-- | List difference. Removes from the first list the first instance of
--   each element of the second list. See '(\)' and <a>deleteFirstsBy</a>
deleteFirsts :: (ListLike full item, Eq item) => full -> full -> full

-- | List union: the set of elements that occur in either list. Duplicate
--   elements in the first list will remain duplicate. See also
--   <a>unionBy</a>.
union :: (ListLike full item, Eq item) => full -> full -> full

-- | List intersection: the set of elements that occur in both lists. See
--   also <a>intersectBy</a>
intersect :: (ListLike full item, Eq item) => full -> full -> full

-- | Sorts the list. On data types that do not preserve ordering, or
--   enforce their own ordering, the result may not be what you expect. See
--   also <a>sortBy</a>.
sort :: (ListLike full item, Ord item) => full -> full

-- | Inserts the element at the last place where it is still less than or
--   equal to the next element. On data types that do not preserve
--   ordering, or enforce their own ordering, the result may not be what
--   you expect. On types such as maps, this may result in changing an
--   existing item. See also <a>insertBy</a>.
insert :: (ListLike full item, Ord item) => item -> full -> full

-- | Converts the structure to a list. This is logically equivolent to
--   <a>fromListLike</a>, but may have a more optimized implementation.
toList :: ListLike full item => full -> [item]

-- | Generates the structure from a list.
fromList :: ListLike full item => [item] -> full

-- | Converts one ListLike to another. See also <a>toList</a>. Default
--   implementation is <tt>fromListLike = map id</tt>
fromListLike :: (ListLike full item, ListLike full' item) => full -> full'

-- | Generic version of <a>nub</a>
nubBy :: ListLike full item => (item -> item -> Bool) -> full -> full

-- | Generic version of <a>deleteBy</a>
deleteBy :: ListLike full item => (item -> item -> Bool) -> item -> full -> full

-- | Generic version of <a>deleteFirsts</a>
deleteFirstsBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>union</a>
unionBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>intersect</a>
intersectBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>group</a>.
groupBy :: (ListLike full item, ListLike full' full, Eq item) => (item -> item -> Bool) -> full -> full'

-- | Sort function taking a custom comparison function
sortBy :: ListLike full item => (item -> item -> Ordering) -> full -> full

-- | Like <a>insert</a>, but with a custom comparison function
insertBy :: ListLike full item => (item -> item -> Ordering) -> item -> full -> full

-- | Length of the list
genericLength :: (ListLike full item, Num a) => full -> a

-- | Generic version of <a>take</a>
genericTake :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>drop</a>
genericDrop :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>splitAt</a>
genericSplitAt :: (ListLike full item, Integral a) => a -> full -> (full, full)

-- | Generic version of <a>replicate</a>
genericReplicate :: (ListLike full item, Integral a) => a -> item -> full

-- | This is the primary class for structures that are to be considered
--   foldable. A minimum complete definition provides <a>foldl</a> and
--   <a>foldr</a>.
--   
--   Instances of <a>FoldableLL</a> can be folded, and can be many and
--   varied.
--   
--   These functions are used heavily in <a>Data.ListLike</a>.
class FoldableLL full item | full -> item where foldl' f a xs = foldr f' id xs a where f' x k z = k $! f z x foldl1 f xs = fromMaybe (error "fold1: empty structure") (foldl mf Nothing xs) where mf Nothing y = Just y mf (Just x) y = Just (f x y) foldr' f a xs = foldl f' id xs a where f' k x z = k $! f x z foldr1 f xs = fromMaybe (error "foldr1: empty structure") (foldr mf Nothing xs) where mf x Nothing = Just x mf x (Just y) = Just (f x y)

-- | Left-associative fold
foldl :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | Strict version of <a>foldl</a>.
foldl' :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | A variant of <a>foldl</a> with no base case. Requires at least 1 list
--   element.
foldl1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | Right-associative fold
foldr :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Strict version of <a>foldr</a>
foldr' :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Like <a>foldr</a>, but with no starting value
foldr1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | An extension to <a>ListLike</a> for those data types that are similar
--   to a <a>String</a>. Minimal complete definition is <a>toString</a> and
--   <a>fromString</a>.
class StringLike s where lines = myLines words = myWords unlines = myUnlines unwords = myUnwords

-- | Converts the structure to a <a>String</a>
toString :: StringLike s => s -> String

-- | Converts a <a>String</a> to a list
fromString :: StringLike s => String -> s

-- | Breaks a string into a list of strings
lines :: (StringLike s, ListLike full s) => s -> full

-- | Breaks a string into a list of words
words :: (StringLike s, ListLike full s) => s -> full

-- | An extension to <a>ListLike</a> for those data types that are capable
--   of dealing with infinite lists. Some <a>ListLike</a> functions are
--   capable of working with finite or infinite lists. The functions here
--   require infinite list capability in order to work at all.
class (ListLike full item) => InfiniteListLike full item | full -> item where iterate f x = cons x (iterate f (f x)) repeat x = xs where xs = cons x xs cycle xs | null xs = error "ListLike.cycle: empty list" | otherwise = xs' where xs' = append xs xs'

-- | An infinite list of repeated calls of the function to args
iterate :: InfiniteListLike full item => (item -> item) -> item -> full

-- | An infinite list where each element is the same
repeat :: InfiniteListLike full item => item -> full

-- | Converts a finite list into a circular one
cycle :: InfiniteListLike full item => full -> full
