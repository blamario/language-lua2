<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Lens.Micro</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Lens-Micro.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Lens-Micro.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">microlens-0.2.0.0: A tiny part of the lens library which you can depend upon</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Lens.Micro</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Setting (applying a function to values)</a></li><li><a href="#g:2">Getting (retrieving a value)</a></li><li><a href="#g:3">Folds (getters returning multiple elements)</a></li><li><a href="#g:4">Lenses (setters and getters at once)</a></li><li><a href="#g:5">Traversals (lenses iterating over several elements)</a></li><li><a href="#g:6">Prisms (traversals iterating over at most 1 element)</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:-38-">(&amp;)</a> :: a -&gt; (a -&gt; b) -&gt; b</li><li class="src short"><span class="keyword">type</span> <a href="#t:ASetter">ASetter</a> s t a b = (a -&gt; <a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a> b) -&gt; s -&gt; <a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a> t</li><li class="src short"><span class="keyword">type</span> <a href="#t:ASetter-39-">ASetter'</a> s a = <a href="Lens-Micro.html#t:ASetter">ASetter</a> s s a a</li><li class="src short"><a href="#v:sets">sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b</li><li class="src short"><a href="#v:-37--126-">(%~)</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t</li><li class="src short"><a href="#v:over">over</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t</li><li class="src short"><a href="#v:.-126-">(.~)</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; b -&gt; s -&gt; t</li><li class="src short"><a href="#v:set">set</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; b -&gt; s -&gt; t</li><li class="src short"><a href="#v:mapped">mapped</a> :: <a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a> f =&gt; <a href="Lens-Micro.html#t:ASetter">ASetter</a> (f a) (f b) a b</li><li class="src short"><span class="keyword">type</span> <a href="#t:Getting">Getting</a> r s a = (a -&gt; <a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a> r a) -&gt; s -&gt; <a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a> r s</li><li class="src short"><a href="#v:-94-.">(^.)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> a s a -&gt; a</li><li class="src short"><a href="#v:-94-..">(^..)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> (<a href="../base-4.8.1.0/Data-Monoid.html#t:Endo">Endo</a> [a]) s a -&gt; [a]</li><li class="src short"><a href="#v:-94--63-">(^?)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> (<a href="../base-4.8.1.0/Data-Monoid.html#t:First">First</a> a) s a -&gt; <a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:-94--63--33-">(^?!)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> (<a href="../base-4.8.1.0/Data-Monoid.html#t:Endo">Endo</a> a) s a -&gt; a</li><li class="src short"><a href="#v:folded">folded</a> :: (<a href="../base-4.8.1.0/Data-Foldable.html#t:Foldable">Foldable</a> f, <a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a> r)) =&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> r (f a) a</li><li class="src short"><a href="#v:has">has</a> :: <a href="Lens-Micro.html#t:Getting">Getting</a> <a href="../base-4.8.1.0/Data-Monoid.html#t:Any">Any</a> s a -&gt; s -&gt; <a href="../base-4.8.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Lens">Lens</a> s t a b = <span class="keyword">forall</span> f. <a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t</li><li class="src short"><span class="keyword">type</span> <a href="#t:Lens-39-">Lens'</a> s a = <a href="Lens-Micro.html#t:Lens">Lens</a> s s a a</li><li class="src short"><a href="#v:lens">lens</a> :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b</li><li class="src short"><a href="#v:at">at</a> :: <a href="Lens-Micro-Classes.html#t:At">At</a> m =&gt; <a href="Lens-Micro-Classes.html#t:Index">Index</a> m -&gt; <a href="Lens-Micro.html#t:Lens-39-">Lens'</a> m (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Lens-Micro-Classes.html#t:IxValue">IxValue</a> m))</li><li class="src short"><a href="#v:_1">_1</a> :: <a href="Lens-Micro-Classes.html#t:Field1">Field1</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b</li><li class="src short"><a href="#v:_2">_2</a> :: <a href="Lens-Micro-Classes.html#t:Field2">Field2</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b</li><li class="src short"><a href="#v:_3">_3</a> :: <a href="Lens-Micro-Classes.html#t:Field3">Field3</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b</li><li class="src short"><a href="#v:_4">_4</a> :: <a href="Lens-Micro-Classes.html#t:Field4">Field4</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b</li><li class="src short"><a href="#v:_5">_5</a> :: <a href="Lens-Micro-Classes.html#t:Field5">Field5</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b</li><li class="src short"><span class="keyword">type</span> <a href="#t:Traversal">Traversal</a> s t a b = <span class="keyword">forall</span> f. <a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t</li><li class="src short"><span class="keyword">type</span> <a href="#t:Traversal-39-">Traversal'</a> s a = <a href="Lens-Micro.html#t:Traversal">Traversal</a> s s a a</li><li class="src short"><a href="#v:both">both</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (a, a) (b, b) a b</li><li class="src short"><a href="#v:traversed">traversed</a> :: <a href="../base-4.8.1.0/Data-Traversable.html#t:Traversable">Traversable</a> f =&gt; <a href="Lens-Micro.html#t:Traversal">Traversal</a> (f a) (f b) a b</li><li class="src short"><a href="#v:each">each</a> :: <a href="Lens-Micro-Classes.html#t:Each">Each</a> s t a b =&gt; <a href="Lens-Micro.html#t:Traversal">Traversal</a> s t a b</li><li class="src short"><a href="#v:ix">ix</a> :: <a href="Lens-Micro-Classes.html#t:Ixed">Ixed</a> m =&gt; <a href="Lens-Micro-Classes.html#t:Index">Index</a> m -&gt; <a href="Lens-Micro.html#t:Traversal-39-">Traversal'</a> m (<a href="Lens-Micro-Classes.html#t:IxValue">IxValue</a> m)</li><li class="src short"><a href="#v:_Left">_Left</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a b) (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a' b) a a'</li><li class="src short"><a href="#v:_Right">_Right</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a b) (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a b') b b'</li><li class="src short"><a href="#v:_Just">_Just</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a) (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a') a a'</li><li class="src short"><a href="#v:_Nothing">_Nothing</a> :: <a href="Lens-Micro.html#t:Traversal-39-">Traversal'</a> (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a) ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:-38-" class="def">(&amp;)</a> :: a -&gt; (a -&gt; b) -&gt; b <span class="fixity">infixl 1</span><span class="rightedge"></span></p><div class="doc"><p><code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> is a reverse application operator.  This provides notational
 convenience.  Its precedence is one higher than that of the forward
 application operator <code><a href="../base-4.8.1.0/Data-Function.html#v:-36-">$</a></code>, which allows <code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> to be nested in <code><a href="../base-4.8.1.0/Data-Function.html#v:-36-">$</a></code>.</p><p><em>Since: 4.8.0.0</em></p></div></div><div class="doc"><p>This operator is useful when you want to modify something several times. For instance, if you want to change 1st and 3rd elements of a tuple, you can write this:</p><pre>(1,2,3) <code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> <code><a href="Lens-Micro.html#v:_1">_1</a></code> <code><a href="Lens-Micro.html#v:.-126-">.~</a></code> 0
        <code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> <code><a href="Lens-Micro.html#v:_3">_3</a></code> <code><a href="Lens-Micro.html#v:-37--126-">%~</a></code> <code><a href="../base-4.8.1.0/Prelude.html#v:negate">negate</a></code>
</pre><p>instead of e.g. this:</p><pre>(<code><a href="Lens-Micro.html#v:_1">_1</a></code> <code><a href="Lens-Micro.html#v:.-126-">.~</a></code> 0) <code><a href="../base-4.8.1.0/Data-Function.html#v:.">.</a></code> (<code><a href="Lens-Micro.html#v:_3">_3</a></code> <code><a href="Lens-Micro.html#v:-37--126-">%~</a></code> <code><a href="../base-4.8.1.0/Prelude.html#v:negate">negate</a></code>) <code><a href="../base-4.8.1.0/Data-Function.html#v:-36-">$</a></code> (1,2,3)
</pre><p>or this:</p><pre><code><a href="Lens-Micro.html#v:set">set</a></code> <code><a href="Lens-Micro.html#v:_1">_1</a></code> 0 <code><a href="../base-4.8.1.0/Data-Function.html#v:.">.</a></code>
<code><a href="Lens-Micro.html#v:over">over</a></code> <code><a href="Lens-Micro.html#v:_3">_3</a></code> <code><a href="../base-4.8.1.0/Prelude.html#v:negate">negate</a></code>
  <code><a href="../base-4.8.1.0/Data-Function.html#v:-36-">$</a></code> (1,2,3)
</pre></div><h1 id="g:1">Setting (applying a function to values)</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ASetter" class="def">ASetter</a> s t a b = (a -&gt; <a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a> b) -&gt; s -&gt; <a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a> t <a href="src/Lens-Micro-Type.html#ASetter" class="link">Source</a></p><div class="doc"><p><code>ASetter s t a b</code> is something that turns a function modifying a value into a function modifying a <em>structure</em>. If you ignore <code><a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a></code> (as <code>Identity a</code> is the same thing as <code>a</code>), the type is:</p><pre>type ASetter s t a b = (a -&gt; b) -&gt; s -&gt; t
</pre><p>This means that examples of setters you might've already seen are:</p><ul><li><pre><code><a href="../base-4.8.1.0/GHC-OldList.html#v:map">map</a></code> :: (a -&gt; b) -&gt; [a] -&gt; [b]</pre></li></ul><p>(which corresponds to <code><a href="Lens-Micro.html#v:mapped">mapped</a></code>)</p><ul><li><pre><code><a href="../base-4.8.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: <code><a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a></code> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</pre></li></ul><p>(which corresponds to <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> as well)</p><ul><li><pre><code><a href="../base-4.8.1.0/Control-Arrow.html#v:first">first</a></code> :: (a -&gt; b) -&gt; (a, x) -&gt; (b, x)</pre></li></ul><p>(which corresponds to <code><a href="Lens-Micro.html#v:_1">_1</a></code>)</p><ul><li><pre><code><a href="../base-4.8.1.0/Control-Arrow.html#v:left">left</a></code> :: (a -&gt; b) -&gt; <code><a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a></code> a x -&gt; <code><a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a></code> b x</pre></li></ul><p>(which corresponds to <code><a href="Lens-Micro.html#v:_Left">_Left</a></code>)</p><p>The reason <code><a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a></code> is used here is for <code><a href="Lens-Micro.html#t:ASetter">ASetter</a></code> to be composable with other types, such as <code><a href="Lens-Micro.html#t:Lens">Lens</a></code>.</p><p>Technically, if you're writing a library, you shouldn't use this type for setters you are exporting from your library; the right type to use is <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter">Setter</a></code>, but it is not provided by this package (because then we'd have to depend on <a href="http://hackage.haskell.org/package/distributive">distributive</a>). It's completely alright, however, to export functions which take an <code><a href="Lens-Micro.html#t:ASetter">ASetter</a></code> as an argument.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ASetter-39-" class="def">ASetter'</a> s a = <a href="Lens-Micro.html#t:ASetter">ASetter</a> s s a a <a href="src/Lens-Micro-Type.html#ASetter%27" class="link">Source</a></p><div class="doc"><p>This is a type alias for monomorphic setters which don't change the type of the container (or of the value inside). It's useful more often than the same type in lens, because we can't provide real setters and so it does the job of both <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:ASetter-39-">ASetter'</a></code> and <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter-39-">Setter'</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:sets" class="def">sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b <a href="src/Lens-Micro-Internal.html#sets" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:sets">sets</a></code> creates an <code><a href="Lens-Micro.html#t:ASetter">ASetter</a></code> from an ordinary function. (The only thing it does is wrapping and unwrapping <code><a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a></code>.)</p></div></div><div class="top"><p class="src"><a name="v:-37--126-" class="def">(%~)</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t <span class="fixity">infixr 4</span><span class="rightedge"></span> <a href="src/Lens-Micro.html#%25~" class="link">Source</a></p><div class="doc"><p>(<code><a href="Lens-Micro.html#v:-37--126-">%~</a></code>) applies a function to the target; an alternative explanation is that it is an inverse of <code><a href="Lens-Micro.html#v:sets">sets</a></code>, which turns a setter into an ordinary function. <code><code><a href="Lens-Micro.html#v:mapped">mapped</a></code> <code><a href="Lens-Micro.html#v:-37--126-">%~</a></code> <code><a href="../base-4.8.1.0/GHC-OldList.html#v:reverse">reverse</a></code></code> is the same thing as <code><code><a href="../base-4.8.1.0/Data-Functor.html#v:fmap">fmap</a></code> <code><a href="../base-4.8.1.0/GHC-OldList.html#v:reverse">reverse</a></code></code>.</p><p>See <code><a href="Lens-Micro.html#v:over">over</a></code> if you want a non-operator synonym.</p><p>Negating the 1st element of a pair:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2) &amp; _1 %~ negate
</code></strong>(-1,2)
</pre><p>Turning all <code>Left</code>s in a list to upper case:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(mapped._Left.mapped %~ toUpper) [Left &quot;foo&quot;, Right &quot;bar&quot;]
</code></strong>[Left &quot;FOO&quot;,Right &quot;bar&quot;]
</pre></div></div><div class="top"><p class="src"><a name="v:over" class="def">over</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t <a href="src/Lens-Micro.html#over" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:over">over</a></code> is a synonym for (<code><a href="Lens-Micro.html#v:-37--126-">%~</a></code>).</p><p>Getting <code><a href="../base-4.8.1.0/Data-Functor.html#v:fmap">fmap</a></code> in a roundabout way:</p><pre><code><a href="Lens-Micro.html#v:over">over</a></code> <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> :: <code><a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a></code> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
<code><a href="Lens-Micro.html#v:over">over</a></code> <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> = <code><a href="../base-4.8.1.0/Data-Functor.html#v:fmap">fmap</a></code>
</pre><p>Applying a function to both components of a pair:</p><pre><code><a href="Lens-Micro.html#v:over">over</a></code> <code><a href="Lens-Micro.html#v:both">both</a></code> :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)
<code><a href="Lens-Micro.html#v:over">over</a></code> <code><a href="Lens-Micro.html#v:both">both</a></code> = \f t -&gt; (f (fst t), f (snd t))
</pre><p>Using <code><code><a href="Lens-Micro.html#v:over">over</a></code> <code><a href="Lens-Micro.html#v:_2">_2</a></code></code> as a replacement for <code><a href="../base-4.8.1.0/Control-Arrow.html#v:second">second</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>over _2 show (10,20)
</code></strong>(10,&quot;20&quot;)
</pre></div></div><div class="top"><p class="src"><a name="v:.-126-" class="def">(.~)</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; b -&gt; s -&gt; t <span class="fixity">infixr 4</span><span class="rightedge"></span> <a href="src/Lens-Micro.html#.~" class="link">Source</a></p><div class="doc"><p>(<code><a href="Lens-Micro.html#v:.-126-">.~</a></code>) assigns a value to the target. These are equivalent:</p><ul><li><pre>l <code><a href="Lens-Micro.html#v:.-126-">.~</a></code> x</pre></li><li><pre>l <code><a href="Lens-Micro.html#v:-37--126-">%~</a></code> <code><a href="../base-4.8.1.0/Data-Function.html#v:const">const</a></code> x</pre></li></ul><p>See <code><a href="Lens-Micro.html#v:set">set</a></code> if you want a non-operator synonym.</p><p>Here it is used to change 2 fields of a 3-tuple:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(0,0,0) &amp; _1 .~ 1 &amp; _3 .~ 3
</code></strong>(1,0,3)
</pre></div></div><div class="top"><p class="src"><a name="v:set" class="def">set</a> :: <a href="Lens-Micro.html#t:ASetter">ASetter</a> s t a b -&gt; b -&gt; s -&gt; t <a href="src/Lens-Micro.html#set" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:set">set</a></code> is a synonym for (<code><a href="Lens-Micro.html#v:.-126-">.~</a></code>).</p><p>Setting the 1st component of a pair:</p><pre><code><a href="Lens-Micro.html#v:set">set</a></code> <code><a href="Lens-Micro.html#v:_1">_1</a></code> :: x -&gt; (a, b) -&gt; (x, b)
<code><a href="Lens-Micro.html#v:set">set</a></code> <code><a href="Lens-Micro.html#v:_1">_1</a></code> = \x t -&gt; (x, snd t)
</pre><p>Using it to rewrite (<code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36-">&lt;$</a></code>):</p><pre><code><a href="Lens-Micro.html#v:set">set</a></code> <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> :: <code><a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a></code> f =&gt; a -&gt; f b -&gt; f a
<code><a href="Lens-Micro.html#v:set">set</a></code> <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> = (<code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36-">&lt;$</a></code>)
</pre></div></div><div class="top"><p class="src"><a name="v:mapped" class="def">mapped</a> :: <a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a> f =&gt; <a href="Lens-Micro.html#t:ASetter">ASetter</a> (f a) (f b) a b <a href="src/Lens-Micro.html#mapped" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:mapped">mapped</a></code> is a setter for everything contained in a functor. You can use it to map over lists, <code>Maybe</code>, or even <code>IO</code> (which is something you can't do with <code><a href="Lens-Micro.html#v:traversed">traversed</a></code> or <code><a href="Lens-Micro.html#v:each">each</a></code>).</p><p>Here <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> is used to turn a value to all non-<code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> values in a list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Just 3,Nothing,Just 5] &amp; mapped.mapped .~ 0
</code></strong>[Just 0,Nothing,Just 0]
</pre><p>Keep in mind that while <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> is a more powerful setter than <code><a href="Lens-Micro.html#v:each">each</a></code>, it can't be used as a getter! This won't work (and will fail with a type error):</p><pre>[(1,2),(3,4),(5,6)] <code><a href="Lens-Micro.html#v:-94-..">^..</a></code> <code><a href="Lens-Micro.html#v:mapped">mapped</a></code> . <code><a href="Lens-Micro.html#v:both">both</a></code>
</pre></div></div><h1 id="g:2">Getting (retrieving a value)</h1><div class="doc"><p>Getters are a not-entirely-obvious way to use lenses to <em>carry out</em> information from a structure (instead of changing something inside the structure). Any lens or traversal is a getter.</p><p>For details, see the documentation for <code><a href="Lens-Micro.html#t:Getting">Getting</a></code>.</p><p>Including <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Getter">Getter</a></code> is impossible, as then this package would have to depend on <a href="http://hackage.haskell.org/package/contravariant">contravariant</a> and it's a big dependency.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Getting" class="def">Getting</a> r s a = (a -&gt; <a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a> r a) -&gt; s -&gt; <a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a> r s <a href="src/Lens-Micro-Type.html#Getting" class="link">Source</a></p><div class="doc"><p>If you take a lens or a traversal and choose <code><code><a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a></code> r</code> as your functor, you will get <code>Getting r s a</code>. This can be used to get something out of the structure instead of modifying it:</p><pre>s <code><a href="Lens-Micro.html#v:-94-.">^.</a></code> l = <code><a href="../base-4.8.1.0/Control-Applicative.html#v:getConst">getConst</a></code> (l <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a></code> s)
</pre><p>Functions that operate on getters &#8211; such as (<code><a href="Lens-Micro.html#v:-94-.">^.</a></code>), (<code><a href="Lens-Micro.html#v:-94-..">^..</a></code>), (<code><a href="Lens-Micro.html#v:-94--63-">^?</a></code>) &#8211; use <code>Getter r s a</code> (with different values of <code>r</code>) to describe what kind of getter they need. For instance, (<code><a href="Lens-Micro.html#v:-94-.">^.</a></code>) needs the getter to be able to return a single value, and so it accepts a getter of type <code>Getting a s a</code>. (<code><a href="Lens-Micro.html#v:-94-..">^..</a></code>) wants the getter to gather values together, so it uses <code>Getting (Endo [a]) s a</code> (it could've used <code>Getting [a] s a</code> instead, but it's faster with <code><a href="../base-4.8.1.0/Data-Monoid.html#v:Endo">Endo</a></code>). The choice of <code>r</code> depends on what you want to do with elements you're extracting from <code>s</code>.</p></div></div><div class="top"><p class="src"><a name="v:-94-." class="def">(^.)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> a s a -&gt; a <span class="fixity">infixl 8</span><span class="rightedge"></span> <a href="src/Lens-Micro.html#%5E." class="link">Source</a></p><div class="doc"><p>(<code><a href="Lens-Micro.html#v:-94-.">^.</a></code>) applies a getter to a value; in other words, it gets a value out of a structure using a getter (which can be a lens, traversal, fold, etc.).</p><p>Getting 1st field of a tuple:</p><pre>(<code><a href="Lens-Micro.html#v:-94-.">^.</a></code> <code><a href="Lens-Micro.html#v:_1">_1</a></code>) :: (a, b) -&gt; a
(<code><a href="Lens-Micro.html#v:-94-.">^.</a></code> <code><a href="Lens-Micro.html#v:_1">_1</a></code>) = <code><a href="../base-4.8.1.0/Data-Tuple.html#v:fst">fst</a></code>
</pre><p>When (<code><a href="Lens-Micro.html#v:-94-.">^.</a></code>) is used with a traversal, it combines all results using the <code><a href="../base-4.8.1.0/Data-Monoid.html#t:Monoid">Monoid</a></code> instance for the resulting type. For instance, for lists it would be simple concatenation:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(&quot;str&quot;,&quot;ing&quot;) ^. each
</code></strong>&quot;string&quot;
</pre><p>The reason for this is that traversals use <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code>, and the <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> instance for <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a></code> uses monoid concatenation to combine &#8220;effects&#8221; of <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a></code>.</p></div></div><h1 id="g:3">Folds (getters returning multiple elements)</h1><div class="doc"><p>Folds are getters that can traverse more than one element (or no elements at all). The only fold here which isn't simultaneously a <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> is <code><a href="Lens-Micro.html#v:folded">folded</a></code> (traversals are folds that also can modify elements they're traversing).</p><p>You can apply folds to values by using operators like (<code><a href="Lens-Micro.html#v:-94-..">^..</a></code>), (<code><a href="Lens-Micro.html#v:-94--63-">^?</a></code>), etc:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2) ^.. both
</code></strong>[1,2]
</pre><p>A nice thing about folds is that you can combine them with (<code><a href="../base-4.8.1.0/Data-Monoid.html#v:-60--62-">&lt;&gt;</a></code>) to concatenate their outputs:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3) ^.. (_2 &lt;&gt; _1)  -- in reversed order because why not
</code></strong>[2,1]
</pre><p>You can build more complicated getters with it when <code><a href="Lens-Micro.html#v:each">each</a></code> would be unhelpful:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>([1,2], 3, [Nothing, Just 4]) ^.. (_1.each &lt;&gt; _2 &lt;&gt; _3.each._Just)
</code></strong>[1,2,3,4]
</pre><p>It plays nicely with (<code><a href="Lens-Micro.html#v:-94--63-">^?</a></code>), too:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..9] ^? (ix 9 &lt;&gt; ix 5)
</code></strong>Just 9
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..8] ^? (ix 9 &lt;&gt; ix 5)
</code></strong>Just 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..3] ^? (ix 9 &lt;&gt; ix 5)
</code></strong>Nothing
</pre><p>(Unfortunately, this trick won't help you with setting or modifying.)</p></div><div class="top"><p class="src"><a name="v:-94-.." class="def">(^..)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> (<a href="../base-4.8.1.0/Data-Monoid.html#t:Endo">Endo</a> [a]) s a -&gt; [a] <span class="fixity">infixl 8</span><span class="rightedge"></span> <a href="src/Lens-Micro.html#%5E.." class="link">Source</a></p><div class="doc"><p><code>s ^.. t</code> returns the list of all values that <code>t</code> gets from <code>s</code>.</p><p>A <code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code> contains either 0 or 1 values:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 3 ^.. _Just
</code></strong>[3]
</pre><p>Gathering all values in a list of tuples:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[(1,2),(3,4)] ^.. each.each
</code></strong>[1,2,3,4]
</pre></div></div><div class="top"><p class="src"><a name="v:-94--63-" class="def">(^?)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> (<a href="../base-4.8.1.0/Data-Monoid.html#t:First">First</a> a) s a -&gt; <a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a <span class="fixity">infixl 8</span><span class="rightedge"></span> <a href="src/Lens-Micro.html#%5E%3F" class="link">Source</a></p><div class="doc"><p><code>s ^? t</code> returns the 1st element <code>t</code> returns, or <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if <code>t</code> doesn't return anything. It's trivially implemented by passing the <code><a href="../base-4.8.1.0/Data-Monoid.html#t:First">First</a></code> monoid to the getter.</p><p>Safe <code><a href="../base-4.8.1.0/GHC-OldList.html#v:head">head</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[] ^? each
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1..3] ^? each
</code></strong>Just 1
</pre><p>Converting <code><a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a></code> to <code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Left 1 ^? _Right
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Right 1 ^? _Right
</code></strong>Just 1
</pre></div></div><div class="top"><p class="src"><a name="v:-94--63--33-" class="def">(^?!)</a> :: s -&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> (<a href="../base-4.8.1.0/Data-Monoid.html#t:Endo">Endo</a> a) s a -&gt; a <span class="fixity">infixl 8</span><span class="rightedge"></span> <a href="src/Lens-Micro.html#%5E%3F%21" class="link">Source</a></p><div class="doc"><p>(<code><a href="Lens-Micro.html#v:-94--63--33-">^?!</a></code>) is an unsafe variant of (<code><a href="Lens-Micro.html#v:-94--63-">^?</a></code>) &#8211; instead of using <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> to indicate that there were no elements returned, it throws an exception.</p></div></div><div class="top"><p class="src"><a name="v:folded" class="def">folded</a> :: (<a href="../base-4.8.1.0/Data-Foldable.html#t:Foldable">Foldable</a> f, <a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a> r)) =&gt; <a href="Lens-Micro.html#t:Getting">Getting</a> r (f a) a <a href="src/Lens-Micro-Internal.html#folded" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:folded">folded</a></code> is a fold for anything <code><a href="../base-4.8.1.0/Data-Foldable.html#t:Foldable">Foldable</a></code>. In a way, it's an opposite of
<code>mapped</code> &#8211; the most powerful getter, but can't be used as a setter.</p></div></div><div class="top"><p class="src"><a name="v:has" class="def">has</a> :: <a href="Lens-Micro.html#t:Getting">Getting</a> <a href="../base-4.8.1.0/Data-Monoid.html#t:Any">Any</a> s a -&gt; s -&gt; <a href="../base-4.8.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Lens-Micro.html#has" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:has">has</a></code> checks whether a getter (any getter, including lenses, traversals, and folds) returns at least 1 value.</p><p>Checking whether a list is non-empty:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has each []
</code></strong>False
</pre><p>You can also use it with e.g. <code><a href="Lens-Micro.html#v:_Left">_Left</a></code> (and other 0-or-1 traversals) as a replacement for <code><a href="../base-4.8.1.0/Data-Maybe.html#v:isNothing">isNothing</a></code>, <code><a href="../base-4.8.1.0/Data-Maybe.html#v:isJust">isJust</a></code> and other <code>isConstructorName</code> functions:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has _Left (Left 1)
</code></strong>True
</pre></div></div><h1 id="g:4">Lenses (setters and getters at once)</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Lens" class="def">Lens</a> s t a b = <span class="keyword">forall</span> f. <a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t <a href="src/Lens-Micro-Type.html#Lens" class="link">Source</a></p><div class="doc"><p>Lenses in a nutshell: use (<code><a href="Lens-Micro.html#v:-94-.">^.</a></code>) to get, (<code><a href="Lens-Micro.html#v:.-126-">.~</a></code>) to set, (<code><a href="Lens-Micro.html#v:-37--126-">%~</a></code>) to modify. (<code><a href="../base-4.8.1.0/Data-Function.html#v:.">.</a></code>) composes lenses (i.e. if a <code>B</code> is a part of <code>A</code>, and a <code>C</code> is a part of in <code>B</code>, then <code>b.c</code> lets you operate on <code>C</code> inside <code>A</code>). You can create lenses with <code><a href="Lens-Micro.html#v:lens">lens</a></code>, or you can write them by hand (see below).</p><p><code>Lens s t a b</code> is the lowest common denominator of a setter and a getter, something that has the power of both; it has a <code><a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a></code> constraint, and since both <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Const">Const</a></code> and <code><a href="../base-4.8.1.0/Data-Functor-Identity.html#t:Identity">Identity</a></code> are functors, it can be used whenever a getter or a setter is needed.</p><ul><li><code>a</code> is the type of the value inside of structure</li><li><code>b</code> is the type of the replaced value</li><li><code>s</code> is the type of the whole structure</li><li><code>t</code> is the type of the structure after replacing <code>a</code> in it with <code>b</code></li></ul><p>A <code><a href="Lens-Micro.html#t:Lens">Lens</a></code> can only point at a single value inside a structure (unlike a <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code>).</p><p>It is easy to write lenses manually. The generic template is:</p><pre>somelens :: Lens s t a b

-- &#8220;f&#8221; is the &#8220;a -&gt; f b&#8221; function, &#8220;s&#8221; is the structure.
somelens f s =
  let
    a = ...                 -- Extract the value from &#8220;s&#8221;.
    rebuildWith b = ...     -- Write a function which would
                            -- combine &#8220;s&#8221; and modified value
                            -- to produce new structure.
  in
    rebuildWith <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f a     -- Apply the structure-producing
                            -- function to the modified value.
</pre><p>Here's the <code><a href="Lens-Micro.html#v:_1">_1</a></code> lens:</p><pre><code><a href="Lens-Micro.html#v:_1">_1</a></code> :: <code><a href="Lens-Micro.html#t:Lens">Lens</a></code> (a, x) (b, x) a b
<code><a href="Lens-Micro.html#v:_1">_1</a></code> f (a, x) = (\b -&gt; (b, x)) <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f a
</pre><p>Here's a more complicated lens, which extracts <em>several</em> values from a structure (in a tuple):</p><pre>type Age     = Int
type City    = String
type Country = String

data Person = Person Age City Country

-- This lens lets you access all location-related information about a person.
location :: <code><a href="Lens-Micro.html#t:Lens-39-">Lens'</a></code> Person (City, Country)
location f (Person age city country) =
  (\(city', country') -&gt; Person age city' country') <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f (city, country)
</pre><p>You even can choose to use a lens to present <em>all</em> information contained in the structure (in a different way). Such lenses are called <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Iso">Iso</a></code> in lens's terminology. For instance (assuming you don't mind functions that can error out), here's a lens which lets you act on the string representation of a value:</p><pre>string :: (Read a, Show a) =&gt; <code><a href="Lens-Micro.html#t:Lens-39-">Lens'</a></code> a String
string f s = read <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f (show s)
</pre><p>Using it to reverse a number:</p><pre>&gt;&gt;&gt; 123 <code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> string <code><a href="Lens-Micro.html#v:-37--126-">%~</a></code> reverse
321
</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Lens-39-" class="def">Lens'</a> s a = <a href="Lens-Micro.html#t:Lens">Lens</a> s s a a <a href="src/Lens-Micro-Type.html#Lens%27" class="link">Source</a></p><div class="doc"><p>This is a type alias for monomorphic lenses which don't change the type of the container (or of the value inside).</p></div></div><div class="top"><p class="src"><a name="v:lens" class="def">lens</a> :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b <a href="src/Lens-Micro.html#lens" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:lens">lens</a></code> creates a <code><a href="Lens-Micro.html#t:Lens">Lens</a></code> from a getter and a setter. The resulting lens isn't the most effective one (because of having to traverse the structure twice when modifying), but it shouldn't matter much.</p><p>A (partial) lens for list indexing:</p><pre>ix :: Int -&gt; <code><a href="Lens-Micro.html#t:Lens-39-">Lens'</a></code> [a] a
ix i = <code><a href="Lens-Micro.html#v:lens">lens</a></code> (<code><a href="../base-4.8.1.0/GHC-OldList.html#v:-33--33-">!!</a></code> i)                                   -- getter
            (\s b -&gt; take i s ++ b : drop (i+1) s)   -- setter
</pre><p>Usage:</p><pre>&gt;&gt;&gt; [1..9] <code><a href="Lens-Micro.html#v:-94-.">^.</a></code> ix 3
4

&gt;&gt;&gt; [1..9] &amp; ix 3 <code><a href="Lens-Micro.html#v:-37--126-">%~</a></code> negate
[1,2,3,-4,5,6,7,8,9]
</pre><p>When getting, the setter is completely unused; when setting, the getter is unused. Both are used only when the value is being modified. For instance, here we define a lens for the 1st element of a list, but instead of a legitimate getter we use <code><a href="../base-4.8.1.0/Prelude.html#v:undefined">undefined</a></code>. Then we use the resulting lens for <em>setting</em> and it works, which proves that the getter wasn't used:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1,2,3] &amp; lens undefined (\s b -&gt; b : tail s) .~ 10
</code></strong>[10,2,3]
</pre></div></div><div class="top"><p class="src"><a name="v:at" class="def">at</a> :: <a href="Lens-Micro-Classes.html#t:At">At</a> m =&gt; <a href="Lens-Micro-Classes.html#t:Index">Index</a> m -&gt; <a href="Lens-Micro.html#t:Lens-39-">Lens'</a> m (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Lens-Micro-Classes.html#t:IxValue">IxValue</a> m)) <a href="src/Lens-Micro-Classes.html#at" class="link">Source</a></p><div class="doc"><p>This lens lets you read, write, or delete elements in <code>Map</code>-like structures. It returns <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> when the value isn't found, just like <code>lookup</code>:</p><pre>Data.Map.lookup k m = m <code><a href="Lens-Micro.html#v:-94-.">^.</a></code> at k
</pre><p>However, it also lets you insert and delete values by setting the value to <code><code><a href="../base-4.8.1.0/Data-Maybe.html#v:Just">Just</a></code> value</code> or <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code>:</p><pre>Data.Map.insert k a m = m <code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> at k <code><a href="Lens-Micro.html#v:.-126-">.~</a></code> Just a

Data.Map.delete k m = m <code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> at k <code><a href="Lens-Micro.html#v:.-126-">.~</a></code> Nothing
</pre><p><code><a href="Lens-Micro.html#v:at">at</a></code> doesn't work for arrays, because you can't delete an arbitrary element from an array.</p><p>If you want to modify an already existing value, you should use <code><a href="Lens-Micro.html#v:ix">ix</a></code> instead because then you won't have to deal with <code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code> (<code><a href="Lens-Micro.html#v:ix">ix</a></code> is available for all types that have <code><a href="Lens-Micro.html#v:at">at</a></code>).</p><p>This package doesn't actually provide any instances for <code><a href="Lens-Micro.html#v:at">at</a></code>, but you can import <code>Lens.Micro.GHC</code> from the <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a> package and get instances for <code>Map</code> and <code>IntMap</code>.</p></div></div><div class="top"><p class="src"><a name="v:_1" class="def">_1</a> :: <a href="Lens-Micro-Classes.html#t:Field1">Field1</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b <a href="src/Lens-Micro-Classes.html#_1" class="link">Source</a></p><div class="doc"><p>Gives access to the 1st field of a tuple (up to 5-tuples).</p><p>Getting the 1st component:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3,4,5) ^. _1
</code></strong>1
</pre><p>Setting the 1st component:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3) &amp; _1 .~ 10
</code></strong>(10,2,3)
</pre><p>Note that this lens is lazy, and can set fields even of <code><a href="../base-4.8.1.0/Prelude.html#v:undefined">undefined</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>set _1 10 undefined :: (Int, Int)
</code></strong>(10,*** Exception: Prelude.undefined
</pre><p>This is done to avoid violating a lens law stating that you can get back what you put:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>view _1 . set _1 10 $ (undefined :: (Int, Int))
</code></strong>10
</pre><p>The implementation (for 2-tuples) is:</p><pre><code><a href="Lens-Micro.html#v:_1">_1</a></code> f t = (,) <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f    (<code><a href="../base-4.8.1.0/Data-Tuple.html#v:fst">fst</a></code> t)
             <code><a href="../base-4.8.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> <code><a href="../base-4.8.1.0/Control-Applicative.html#v:pure">pure</a></code> (<code><a href="../base-4.8.1.0/Data-Tuple.html#v:snd">snd</a></code> t)
</pre><p>or, alternatively,</p><pre><code><a href="Lens-Micro.html#v:_1">_1</a></code> f ~(a,b) = (\a' -&gt; (a',b)) <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f a
</pre><p>(where <code>~</code> means a <a href="https://wiki.haskell.org/Lazy_pattern_match">lazy pattern</a>).</p><p><code><a href="Lens-Micro.html#v:_2">_2</a></code>, <code><a href="Lens-Micro.html#v:_3">_3</a></code>, <code><a href="Lens-Micro.html#v:_4">_4</a></code>, and <code><a href="Lens-Micro.html#v:_5">_5</a></code> are also available (see below).</p></div></div><div class="top"><p class="src"><a name="v:_2" class="def">_2</a> :: <a href="Lens-Micro-Classes.html#t:Field2">Field2</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b <a href="src/Lens-Micro-Classes.html#_2" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:_3" class="def">_3</a> :: <a href="Lens-Micro-Classes.html#t:Field3">Field3</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b <a href="src/Lens-Micro-Classes.html#_3" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:_4" class="def">_4</a> :: <a href="Lens-Micro-Classes.html#t:Field4">Field4</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b <a href="src/Lens-Micro-Classes.html#_4" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:_5" class="def">_5</a> :: <a href="Lens-Micro-Classes.html#t:Field5">Field5</a> s t a b =&gt; <a href="Lens-Micro.html#t:Lens">Lens</a> s t a b <a href="src/Lens-Micro-Classes.html#_5" class="link">Source</a></p></div><h1 id="g:5">Traversals (lenses iterating over several elements)</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Traversal" class="def">Traversal</a> s t a b = <span class="keyword">forall</span> f. <a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t <a href="src/Lens-Micro-Type.html#Traversal" class="link">Source</a></p><div class="doc"><p>Traversals in a nutshell: they're like lenses but they can point at multiple values. Use (<code><a href="Lens-Micro.html#v:-94-..">^..</a></code>) to get all values, (<code><a href="Lens-Micro.html#v:-94--63-">^?</a></code>) to get the 1st value, (<code><a href="Lens-Micro.html#v:.-126-">.~</a></code>) to set values, (<code><a href="Lens-Micro.html#v:-37--126-">%~</a></code>) to modify them. (<code><a href="../base-4.8.1.0/Data-Function.html#v:.">.</a></code>) composes traversals just as it composes lenses. (<code><a href="Lens-Micro.html#v:-94-.">^.</a></code>) can be used with traversals as well, but don't confuse it with (<code><a href="Lens-Micro.html#v:-94-..">^..</a></code>).</p><p><code>Traversal s t a b</code> is a generalisation of <code><a href="Lens-Micro.html#t:Lens">Lens</a></code> which allows many targets (possibly 0). It's achieved by changing the constraint to <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> instead of <code><a href="../base-4.8.1.0/Data-Functor.html#t:Functor">Functor</a></code> &#8211; indeed, the point of <code><a href="../base-4.8.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> is that you can combine effects, which is just what we need to have many targets.</p><p>Traversals don't differ from lenses when it comes to setting &#8211; you can use usual (<code><a href="Lens-Micro.html#v:-37--126-">%~</a></code>) and (<code><a href="Lens-Micro.html#v:.-126-">.~</a></code>) to modify and set values. Getting is a bit different, because you have to decide what to do in the case of multiple values. In particular, you can use these combinators (as well as everything else in the &#8220;Folds&#8221; section):</p><ul><li>(<code><a href="Lens-Micro.html#v:-94-..">^..</a></code>) gets a list of values</li><li>(<code><a href="Lens-Micro.html#v:-94--63-">^?</a></code>) gets the 1st value (or <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if there are no values)</li><li>(<code><a href="Lens-Micro.html#v:-94--63--33-">^?!</a></code>) gets the 1st value and throws an exception if there are no values</li></ul><p>In addition, (<code><a href="Lens-Micro.html#v:-94-.">^.</a></code>) works for traversals as well &#8211; it combines traversed values using the (<code><a href="../base-4.8.1.0/Data-Monoid.html#v:-60--62-">&lt;&gt;</a></code>) operation (if the values are instances of <code><a href="../base-4.8.1.0/Data-Monoid.html#t:Monoid">Monoid</a></code>).</p><p>Traversing any value twice is a violation of traversal laws. You can, however, traverse values in any order.</p><p>Ultimately, traversals should follow 2 laws:</p><pre>t pure &#8801; pure
fmap (t f) . t g &#8801; getCompose . t (Compose . fmap f . g)
</pre><p>The 1st law states that you can't change the shape of the structure or do anything funny with elements (traverse elements which aren't in the structure, create new elements out of thin air, etc.). The 2nd law states that you should be able to fuse 2 identical traversals into one. For a more detailed explanation of the laws, see <a href="http://artyom.me/lens-over-tea-2#traversal-laws">this blog post</a> (if you prefer rambling blog posts), or <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence Of The Iterator Pattern</a> (if you prefer papers).</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Traversal-39-" class="def">Traversal'</a> s a = <a href="Lens-Micro.html#t:Traversal">Traversal</a> s s a a <a href="src/Lens-Micro-Type.html#Traversal%27" class="link">Source</a></p><div class="doc"><p>This is a type alias for monomorphic traversals which don't change the type of the container (or of the values inside).</p></div></div><div class="top"><p class="src"><a name="v:both" class="def">both</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (a, a) (b, b) a b <a href="src/Lens-Micro.html#both" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:both">both</a></code> traverses both fields of a tuple. Unlike <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:both">both</a></code> from lens, it only works for pairs &#8211; not for triples or <code><a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(&quot;str&quot;,&quot;ing&quot;) ^. both
</code></strong>&quot;string&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(&quot;str&quot;,&quot;ing&quot;) &amp; both %~ reverse
</code></strong>(&quot;rts&quot;,&quot;gni&quot;)
</pre></div></div><div class="top"><p class="src"><a name="v:traversed" class="def">traversed</a> :: <a href="../base-4.8.1.0/Data-Traversable.html#t:Traversable">Traversable</a> f =&gt; <a href="Lens-Micro.html#t:Traversal">Traversal</a> (f a) (f b) a b <a href="src/Lens-Micro-Internal.html#traversed" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:traversed">traversed</a></code> traverses any <code><a href="../base-4.8.1.0/Data-Traversable.html#t:Traversable">Traversable</a></code> container (list, vector, <code>Map</code>, <code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code>, you name it):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 ^.. traversed
</code></strong>[1]
</pre><p><code><a href="Lens-Micro.html#v:traversed">traversed</a></code> is the same as <code><a href="../base-4.8.1.0/Data-Traversable.html#v:traverse">traverse</a></code>, but can be faster thanks to magic rewrite rules.</p></div></div><div class="top"><p class="src"><a name="v:each" class="def">each</a> :: <a href="Lens-Micro-Classes.html#t:Each">Each</a> s t a b =&gt; <a href="Lens-Micro.html#t:Traversal">Traversal</a> s t a b <a href="src/Lens-Micro-Classes.html#each" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:each">each</a></code> tries to be a universal <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> &#8211; it behaves like <code><a href="Lens-Micro.html#v:traversed">traversed</a></code> in most situations, but also adds support for e.g. tuples with same-typed values:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2) &amp; each %~ succ
</code></strong>(2,3)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] ^. each
</code></strong>&quot;xyz&quot;
</pre><p>However, note that <code><a href="Lens-Micro.html#v:each">each</a></code> doesn't work on <em>every</em> instance of <code><a href="../base-4.8.1.0/Data-Traversable.html#t:Traversable">Traversable</a></code>. If you have a <code><a href="../base-4.8.1.0/Data-Traversable.html#t:Traversable">Traversable</a></code> which isn't supported by <code><a href="Lens-Micro.html#v:each">each</a></code>, you can use <code><a href="Lens-Micro.html#v:traversed">traversed</a></code> instead. Personally, I like using <code><a href="Lens-Micro.html#v:each">each</a></code> instead of <code><a href="Lens-Micro.html#v:traversed">traversed</a></code> whenever possible &#8211; it's shorter and more descriptive.</p><p>You can use <code><a href="Lens-Micro.html#v:each">each</a></code> with these things:</p><pre><code><a href="Lens-Micro.html#v:each">each</a></code> :: <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> [a] [b] a b

<code><a href="Lens-Micro.html#v:each">each</a></code> :: <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> (<code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code> a) (<code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code> b) a b

<code><a href="Lens-Micro.html#v:each">each</a></code> :: <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> (a,a) (b,b) a b
<code><a href="Lens-Micro.html#v:each">each</a></code> :: <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> (a,a,a) (b,b,b) a b
<code><a href="Lens-Micro.html#v:each">each</a></code> :: <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> (a,a,a,a) (b,b,b,b) a b
<code><a href="Lens-Micro.html#v:each">each</a></code> :: <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> (a,a,a,a,a) (b,b,b,b,b) a b

<code><a href="Lens-Micro.html#v:each">each</a></code> :: (<code><a href="../base-4.8.1.0/Prelude.html#t:RealFloat">RealFloat</a></code> a, <code><a href="../base-4.8.1.0/Prelude.html#t:RealFloat">RealFloat</a></code> b) =&gt; <code><a href="Lens-Micro.html#t:Traversal">Traversal</a></code> (<code><a href="../base-4.8.1.0/Data-Complex.html#t:Complex">Complex</a></code> a) (<code><a href="../base-4.8.1.0/Data-Complex.html#t:Complex">Complex</a></code> b) a b
</pre><p>Additionally, you can use <code><a href="Lens-Micro.html#v:each">each</a></code> with types from <a href="http://hackage.haskell.org/package/array">array</a>, <a href="http://hackage.haskell.org/package/bytestring">bytestring</a>, and <a href="http://hackage.haskell.org/package/containers">containers</a> by importing <code>Lens.Micro.GHC</code> from the <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a> package.</p></div></div><div class="top"><p class="src"><a name="v:ix" class="def">ix</a> :: <a href="Lens-Micro-Classes.html#t:Ixed">Ixed</a> m =&gt; <a href="Lens-Micro-Classes.html#t:Index">Index</a> m -&gt; <a href="Lens-Micro.html#t:Traversal-39-">Traversal'</a> m (<a href="Lens-Micro-Classes.html#t:IxValue">IxValue</a> m) <a href="src/Lens-Micro-Classes.html#ix" class="link">Source</a></p><div class="doc"><p>This traversal lets you access (and update) an arbitrary element in a list, array, <code>Map</code>, etc. (If you want to insert or delete elements as well, look at <code><a href="Lens-Micro.html#v:at">at</a></code>.)</p><p>An example for lists:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..5] &amp; ix 3 .~ 10
</code></strong>[0,1,2,100,4,5]
</pre><p>You can use it for getting, too:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..5] ^? ix 3
</code></strong>Just 3
</pre><p>Of course, the element may not be present (which means that you can use <code><a href="Lens-Micro.html#v:ix">ix</a></code> as a safe variant of (<code><a href="../base-4.8.1.0/GHC-OldList.html#v:-33--33-">!!</a></code>)):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..5] ^? ix 10
</code></strong>Nothing
</pre><p>Another useful instance is the one for functions &#8211; it lets you modify their outputs for specific inputs. For instance, here's <code><a href="../base-4.8.1.0/Data-Foldable.html#v:maximum">maximum</a></code> that returns 0 when the list is empty (instead of throwing an exception):</p><pre>maximum0 = <code><a href="../base-4.8.1.0/Data-Foldable.html#v:maximum">maximum</a></code> <code><a href="Lens-Micro.html#v:-38-">&amp;</a></code> <code><a href="Lens-Micro.html#v:ix">ix</a></code> [] <code><a href="Lens-Micro.html#v:.-126-">.~</a></code> 0
</pre><p>The following instances are provided in this package:</p><pre><code><a href="Lens-Micro.html#v:ix">ix</a></code> :: <code><a href="../base-4.8.1.0/Data-Int.html#t:Int">Int</a></code> -&gt; <code><a href="Lens-Micro.html#t:Traversal-39-">Traversal'</a></code> [a] a

<code><a href="Lens-Micro.html#v:ix">ix</a></code> :: (<code><a href="../base-4.8.1.0/Data-Eq.html#t:Eq">Eq</a></code> e) =&gt; e -&gt; <code><a href="Lens-Micro.html#t:Traversal-39-">Traversal'</a></code> (e -&gt; a) a
</pre><p>Additionally, you can use <code><a href="Lens-Micro.html#v:ix">ix</a></code> with types from <a href="http://hackage.haskell.org/package/array">array</a>, <a href="http://hackage.haskell.org/package/bytestring">bytestring</a>, and <a href="http://hackage.haskell.org/package/containers">containers</a> by importing <code>Lens.Micro.GHC</code> from the <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a> package.</p></div></div><h1 id="g:6">Prisms (traversals iterating over at most 1 element)</h1><div class="doc"><p>Prisms are traversals that always target 0 or 1 values. Moreover, it's possible to <em>reverse</em> a prism, using it to construct a structure instead of peeking into it. Here's an example from the lens library:</p><pre>&gt;&gt;&gt; over _Left (+1) (Left 2)
Left 3

&gt;&gt;&gt; _Left # 5
Left 5
</pre><p>However, it's not possible for microlens to export prisms, because their type depends on <code><a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#t:Choice">Choice</a></code>, which resides in the <a href="http://hackage.haskell.org/package/profunctors">profunctors</a> library, which is a somewhat huge dependency. So, all prisms included here are traversals instead.</p></div><div class="top"><p class="src"><a name="v:_Left" class="def">_Left</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a b) (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a' b) a a' <a href="src/Lens-Micro.html#_Left" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:_Left">_Left</a></code> targets the value contained in an <code><a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a></code>, provided it's a <code><a href="../base-4.8.1.0/Data-Either.html#v:Left">Left</a></code>.</p><p>Gathering all <code>Left</code>s in a structure (like the <code><a href="../base-4.8.1.0/Data-Either.html#v:lefts">lefts</a></code> function, but not necessarily just for lists):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Left 1, Right 'c', Left 3] ^.. each._Just
</code></strong>[1,3]
</pre><p>Checking whether an <code><a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a></code> is a <code><a href="../base-4.8.1.0/Data-Either.html#v:Left">Left</a></code> (like <code><a href="../base-4.8.1.0/Data-Either.html#v:isLeft">isLeft</a></code>):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has _Left (Left 1)
</code></strong>True
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has _Left (Right 1)
</code></strong>False
</pre><p>Extracting a value (if you're sure it's a <code><a href="../base-4.8.1.0/Data-Either.html#v:Left">Left</a></code>):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Left 1 ^?! _Left
</code></strong>1
</pre><p>Mapping over all <code><a href="../base-4.8.1.0/Data-Either.html#v:Left">Left</a></code>s:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(each._Left %~ map toUpper) [Left &quot;foo&quot;, Right &quot;bar&quot;]
</code></strong>[Left &quot;FOO&quot;,Right &quot;bar&quot;]
</pre><p>Implementation:</p><pre><code><a href="Lens-Micro.html#v:_Left">_Left</a></code> f (Left a)  = <code><a href="../base-4.8.1.0/Data-Either.html#v:Left">Left</a></code> <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f a
<code><a href="Lens-Micro.html#v:_Left">_Left</a></code> _ (Right b) = <code><a href="../base-4.8.1.0/Control-Applicative.html#v:pure">pure</a></code> (<code><a href="../base-4.8.1.0/Data-Either.html#v:Right">Right</a></code> b)
</pre></div></div><div class="top"><p class="src"><a name="v:_Right" class="def">_Right</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a b) (<a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a> a b') b b' <a href="src/Lens-Micro.html#_Right" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:_Right">_Right</a></code> targets the value contained in an <code><a href="../base-4.8.1.0/Data-Either.html#t:Either">Either</a></code>, provided it's a <code><a href="../base-4.8.1.0/Data-Either.html#v:Right">Right</a></code>.</p><p>See documentation for <code><a href="Lens-Micro.html#v:_Left">_Left</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:_Just" class="def">_Just</a> :: <a href="Lens-Micro.html#t:Traversal">Traversal</a> (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a) (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a') a a' <a href="src/Lens-Micro.html#_Just" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:_Just">_Just</a></code> targets the value contained in a <code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code>, provided it's a <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Just">Just</a></code>.</p><p>See documentation for <code><a href="Lens-Micro.html#v:_Left">_Left</a></code> (as these 2 are pretty similar). In particular, it can be used to write these:</p><ul><li>Unsafely extracting a value from a <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Just">Just</a></code>:</li></ul><pre>   <code><a href="../base-4.8.1.0/Data-Maybe.html#v:fromJust">fromJust</a></code> = (<code><a href="Lens-Micro.html#v:-94--63--33-">^?!</a></code> <code><a href="Lens-Micro.html#v:_Just">_Just</a></code>)
   </pre><ul><li>Checking whether a value is a <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Just">Just</a></code>:</li></ul><pre>   <code><a href="../base-4.8.1.0/Data-Maybe.html#v:isJust">isJust</a></code> = <code><a href="Lens-Micro.html#v:has">has</a></code> <code><a href="Lens-Micro.html#v:_Just">_Just</a></code>
   </pre><ul><li>Converting a <code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code> to a list (empty or consisting of a single element):</li></ul><pre>   <code><a href="../base-4.8.1.0/Data-Maybe.html#v:maybeToList">maybeToList</a></code> = (<code><a href="Lens-Micro.html#v:-94-..">^..</a></code> <code><a href="Lens-Micro.html#v:_Just">_Just</a></code>)
   </pre><ul><li>Gathering all <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Just">Just</a></code>s in a list:</li></ul><pre>   <code><a href="../base-4.8.1.0/Data-Maybe.html#v:catMaybes">catMaybes</a></code> = (<code><a href="Lens-Micro.html#v:-94-..">^..</a></code> <code><a href="Lens-Micro.html#v:each">each</a></code> <code><a href="../base-4.8.1.0/Data-Function.html#v:.">.</a></code> <code><a href="Lens-Micro.html#v:_Just">_Just</a></code>)
   </pre></div></div><div class="top"><p class="src"><a name="v:_Nothing" class="def">_Nothing</a> :: <a href="Lens-Micro.html#t:Traversal-39-">Traversal'</a> (<a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a) () <a href="src/Lens-Micro.html#_Nothing" class="link">Source</a></p><div class="doc"><p><code><a href="Lens-Micro.html#v:_Nothing">_Nothing</a></code> targets a <code>()</code> if the <code><a href="../base-4.8.1.0/Data-Maybe.html#t:Maybe">Maybe</a></code> is a <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code>, and doesn't target anything otherwise:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 ^.. _Nothing
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Nothing ^.. _Nothing
</code></strong>[()]
</pre><p>It's not particularly useful (unless you want to use <code><code><a href="Lens-Micro.html#v:has">has</a></code> <code><a href="Lens-Micro.html#v:_Nothing">_Nothing</a></code></code> as a replacement for <code><a href="../base-4.8.1.0/Data-Maybe.html#v:isNothing">isNothing</a></code>), and provided mainly for consistency.</p><p>Implementation:</p><pre><code><a href="Lens-Micro.html#v:_Nothing">_Nothing</a></code> f Nothing = <code><a href="../base-4.8.1.0/Data-Function.html#v:const">const</a></code> <code><a href="../base-4.8.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> <code><a href="../base-4.8.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> f ()
<code><a href="Lens-Micro.html#v:_Nothing">_Nothing</a></code> _ j       = <code><a href="../base-4.8.1.0/Control-Applicative.html#v:pure">pure</a></code> j
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>