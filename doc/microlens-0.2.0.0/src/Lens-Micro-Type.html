<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Lens/Micro/Type.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE
<a name="line-2"></a>RankNTypes
<a name="line-3"></a>  #-}</span>
<a name="line-4"></a>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>{- |
<a name="line-7"></a>This module provides just the types ('Lens', 'Traversal', etc). It's needed to break the dependency cycle – "Lens.Micro" depends on "Lens.Micro.Classes", but "Lens.Micro.Classes" needs types like 'Lens', so 'Lens' can't be defined in "Lens.Micro".
<a name="line-8"></a>-}</span>
<a name="line-9"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Micro</span><span class='hs-varop'>.</span><span class='hs-conid'>Type</span>
<a name="line-10"></a><span class='hs-layout'>(</span>
<a name="line-11"></a>  <span class='hs-conid'>ASetter</span><span class='hs-layout'>,</span> <span class='hs-conid'>ASetter'</span><span class='hs-layout'>,</span>
<a name="line-12"></a>  <span class='hs-conid'>Getting</span><span class='hs-layout'>,</span>
<a name="line-13"></a>  <span class='hs-conid'>Lens</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lens'</span><span class='hs-layout'>,</span>
<a name="line-14"></a>  <span class='hs-conid'>Traversal</span><span class='hs-layout'>,</span> <span class='hs-conid'>Traversal'</span><span class='hs-layout'>,</span>
<a name="line-15"></a><span class='hs-layout'>)</span>
<a name="line-16"></a><span class='hs-keyword'>where</span>
<a name="line-17"></a>
<a name="line-18"></a>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Functor</span><span class='hs-varop'>.</span><span class='hs-conid'>Identity</span>
<a name="line-21"></a>
<a name="line-22"></a>
<a name="line-23"></a><a name="ASetter"></a><span class='hs-comment'>{- |
<a name="line-24"></a>@ASetter s t a b@ is something that turns a function modifying a value into a function modifying a /structure/. If you ignore 'Identity' (as @Identity a@ is the same thing as @a@), the type is:
<a name="line-25"></a>
<a name="line-26"></a>@
<a name="line-27"></a>type ASetter s t a b = (a -&gt; b) -&gt; s -&gt; t
<a name="line-28"></a>@
<a name="line-29"></a>
<a name="line-30"></a>This means that examples of setters you might've already seen are:
<a name="line-31"></a>
<a name="line-32"></a>  * @'map' :: (a -&gt; b) -&gt; [a] -&gt; [b]@
<a name="line-33"></a>
<a name="line-34"></a>    (which corresponds to 'Lens.Micro.mapped')
<a name="line-35"></a>
<a name="line-36"></a>  * @'fmap' :: 'Functor' f =&gt; (a -&gt; b) -&gt; f a -&gt; f b@
<a name="line-37"></a>
<a name="line-38"></a>    (which corresponds to 'Lens.Micro.mapped' as well)
<a name="line-39"></a>
<a name="line-40"></a>  * @'Control.Arrow.first' :: (a -&gt; b) -&gt; (a, x) -&gt; (b, x)@
<a name="line-41"></a>
<a name="line-42"></a>    (which corresponds to 'Lens.Micro._1')
<a name="line-43"></a>
<a name="line-44"></a>  * @'Control.Arrow.left' :: (a -&gt; b) -&gt; 'Either' a x -&gt; 'Either' b x@
<a name="line-45"></a>
<a name="line-46"></a>    (which corresponds to 'Lens.Micro._Left')
<a name="line-47"></a>
<a name="line-48"></a>The reason 'Identity' is used here is for 'ASetter' to be composable with other types, such as 'Lens'.
<a name="line-49"></a>
<a name="line-50"></a>Technically, if you're writing a library, you shouldn't use this type for setters you are exporting from your library; the right type to use is @&lt;<a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter">http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter</a> Setter&gt;@, but it is not provided by this package (because then we'd have to depend on &lt;<a href="http://hackage.haskell.org/package/distributive">http://hackage.haskell.org/package/distributive</a> distributive&gt;). It's completely alright, however, to export functions which take an 'ASetter' as an argument.
<a name="line-51"></a>-}</span>
<a name="line-52"></a><a name="ASetter"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ASetter</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Identity</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Identity</span> <span class='hs-varid'>t</span>
<a name="line-53"></a>
<a name="line-54"></a><a name="ASetter'"></a><span class='hs-comment'>{- |
<a name="line-55"></a>This is a type alias for monomorphic setters which don't change the type of the container (or of the value inside). It's useful more often than the same type in lens, because we can't provide real setters and so it does the job of both @&lt;<a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:ASetter-39-">http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:ASetter-39-</a> ASetter'&gt;@ and @&lt;<a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter-39-">http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter-39-</a> Setter'&gt;@.
<a name="line-56"></a>-}</span>
<a name="line-57"></a><a name="ASetter'"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ASetter'</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASetter</span> <span class='hs-varid'>s</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a</span>
<a name="line-58"></a>
<a name="line-59"></a><a name="Getting"></a><span class='hs-comment'>{- |
<a name="line-60"></a>If you take a lens or a traversal and choose @'Const' r@ as your functor, you will get @Getting r s a@. This can be used to get something out of the structure instead of modifying it:
<a name="line-61"></a>
<a name="line-62"></a>@
<a name="line-63"></a>s 'Lens.Micro.^.' l = 'getConst' (l 'Const' s)
<a name="line-64"></a>@
<a name="line-65"></a>
<a name="line-66"></a>Functions that operate on getters – such as ('Lens.Micro.^.'), ('Lens.Micro.^..'), ('Lens.Micro.^?') – use @Getter r s a@ (with different values of @r@) to describe what kind of getter they need. For instance, ('Lens.Micro.^.') needs the getter to be able to return a single value, and so it accepts a getter of type @Getting a s a@. ('Lens.Micro.^..') wants the getter to gather values together, so it uses @Getting (Endo [a]) s a@ (it could've used @Getting [a] s a@ instead, but it's faster with 'Data.Monoid.Endo'). The choice of @r@ depends on what you want to do with elements you're extracting from @s@.
<a name="line-67"></a>-}</span>
<a name="line-68"></a><a name="Getting"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Getting</span> <span class='hs-varid'>r</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Const</span> <span class='hs-varid'>r</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Const</span> <span class='hs-varid'>r</span> <span class='hs-varid'>s</span>
<a name="line-69"></a>
<a name="line-70"></a><a name="Lens"></a><span class='hs-comment'>{- |
<a name="line-71"></a>Lenses in a nutshell: use ('Lens.Micro.^.') to get, ('Lens.Micro..~') to set, ('Lens.Micro.%~') to modify. ('.') composes lenses (i.e. if a @B@ is a part of @A@, and a @C@ is a part of in @B@, then @b.c@ lets you operate on @C@ inside @A@). You can create lenses with 'Lens.Micro.lens', or you can write them by hand (see below).
<a name="line-72"></a>
<a name="line-73"></a>@Lens s t a b@ is the lowest common denominator of a setter and a getter, something that has the power of both; it has a 'Functor' constraint, and since both 'Const' and 'Identity' are functors, it can be used whenever a getter or a setter is needed.
<a name="line-74"></a>
<a name="line-75"></a>  * @a@ is the type of the value inside of structure
<a name="line-76"></a>  * @b@ is the type of the replaced value
<a name="line-77"></a>  * @s@ is the type of the whole structure
<a name="line-78"></a>  * @t@ is the type of the structure after replacing @a@ in it with @b@
<a name="line-79"></a>
<a name="line-80"></a>A 'Lens' can only point at a single value inside a structure (unlike a 'Traversal').
<a name="line-81"></a>
<a name="line-82"></a>It is easy to write lenses manually. The generic template is:
<a name="line-83"></a>
<a name="line-84"></a>@
<a name="line-85"></a>somelens :: Lens s t a b
<a name="line-86"></a>
<a name="line-87"></a>-- “f” is the “a -&gt; f b” function, “s” is the structure.
<a name="line-88"></a>somelens f s =
<a name="line-89"></a>  let
<a name="line-90"></a>    a = ...                 -- Extract the value from “s”.
<a name="line-91"></a>    rebuildWith b = ...     -- Write a function which would
<a name="line-92"></a>                            -- combine “s” and modified value
<a name="line-93"></a>                            -- to produce new structure.
<a name="line-94"></a>  in
<a name="line-95"></a>    rebuildWith '&lt;$&gt;' f a     -- Apply the structure-producing
<a name="line-96"></a>                            -- function to the modified value.
<a name="line-97"></a>@
<a name="line-98"></a>
<a name="line-99"></a>Here's the 'Lens.Micro._1' lens:
<a name="line-100"></a>
<a name="line-101"></a>@
<a name="line-102"></a>'Lens.Micro._1' :: 'Lens' (a, x) (b, x) a b
<a name="line-103"></a>'Lens.Micro._1' f (a, x) = (\\b -&gt; (b, x)) '&lt;$&gt;' f a
<a name="line-104"></a>@
<a name="line-105"></a>
<a name="line-106"></a>Here's a more complicated lens, which extracts /several/ values from a structure (in a tuple):
<a name="line-107"></a>
<a name="line-108"></a>@
<a name="line-109"></a>type Age     = Int
<a name="line-110"></a>type City    = String
<a name="line-111"></a>type Country = String
<a name="line-112"></a>
<a name="line-113"></a>data Person = Person Age City Country
<a name="line-114"></a>
<a name="line-115"></a>-- This lens lets you access all location-related information about a person.
<a name="line-116"></a>location :: 'Lens'' Person (City, Country)
<a name="line-117"></a>location f (Person age city country) =
<a name="line-118"></a>  (\\(city', country') -&gt; Person age city' country') '&lt;$&gt;' f (city, country)
<a name="line-119"></a>@
<a name="line-120"></a>
<a name="line-121"></a>You even can choose to use a lens to present /all/ information contained in the structure (in a different way). Such lenses are called @&lt;<a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Iso">http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Iso</a> Iso&gt;@ in lens's terminology. For instance (assuming you don't mind functions that can error out), here's a lens which lets you act on the string representation of a value:
<a name="line-122"></a>
<a name="line-123"></a>@
<a name="line-124"></a>string :: (Read a, Show a) =&gt; 'Lens'' a String
<a name="line-125"></a>string f s = read '&lt;$&gt;' f (show s)
<a name="line-126"></a>@
<a name="line-127"></a>
<a name="line-128"></a>Using it to reverse a number:
<a name="line-129"></a>
<a name="line-130"></a>@
<a name="line-131"></a>&gt;&gt;&gt; 123 'Lens.Micro.&amp;' string 'Lens.Micro.%~' reverse
<a name="line-132"></a>321
<a name="line-133"></a>@
<a name="line-134"></a>-}</span>
<a name="line-135"></a><a name="Lens"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Lens</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>f</span><span class='hs-varop'>.</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>t</span>
<a name="line-136"></a>
<a name="line-137"></a><a name="Lens'"></a><span class='hs-comment'>{- |
<a name="line-138"></a>This is a type alias for monomorphic lenses which don't change the type of the container (or of the value inside).
<a name="line-139"></a>-}</span>
<a name="line-140"></a><a name="Lens'"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Lens'</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lens</span> <span class='hs-varid'>s</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a</span>
<a name="line-141"></a>
<a name="line-142"></a><a name="Traversal"></a><span class='hs-comment'>{- |
<a name="line-143"></a>Traversals in a nutshell: they're like lenses but they can point at multiple values. Use ('Lens.Micro.^..') to get all values, ('Lens.Micro.^?') to get the 1st value, ('Lens.Micro..~') to set values, ('Lens.Micro.%~') to modify them. ('.') composes traversals just as it composes lenses. ('Lens.Micro.^.') can be used with traversals as well, but don't confuse it with ('Lens.Micro.^..').
<a name="line-144"></a>
<a name="line-145"></a>@Traversal s t a b@ is a generalisation of 'Lens' which allows many targets (possibly 0). It's achieved by changing the constraint to 'Applicative' instead of 'Functor' – indeed, the point of 'Applicative' is that you can combine effects, which is just what we need to have many targets.
<a name="line-146"></a>
<a name="line-147"></a>Traversals don't differ from lenses when it comes to setting – you can use usual ('Lens.Micro.%~') and ('Lens.Micro..~') to modify and set values. Getting is a bit different, because you have to decide what to do in the case of multiple values. In particular, you can use these combinators (as well as everything else in the “Folds” section):
<a name="line-148"></a>
<a name="line-149"></a>  * ('Lens.Micro.^..') gets a list of values
<a name="line-150"></a>  * ('Lens.Micro.^?') gets the 1st value (or 'Nothing' if there are no values)
<a name="line-151"></a>  * ('Lens.Micro.^?!') gets the 1st value and throws an exception if there are no values
<a name="line-152"></a>
<a name="line-153"></a>In addition, ('Lens.Micro.^.') works for traversals as well – it combines traversed values using the ('Data.Monoid.&lt;&gt;') operation (if the values are instances of 'Monoid').
<a name="line-154"></a>
<a name="line-155"></a>Traversing any value twice is a violation of traversal laws. You can, however, traverse values in any order.
<a name="line-156"></a>
<a name="line-157"></a>Ultimately, traversals should follow 2 laws:
<a name="line-158"></a>
<a name="line-159"></a>@
<a name="line-160"></a>t pure ≡ pure
<a name="line-161"></a>fmap (t f) . t g ≡ getCompose . t (Compose . fmap f . g)
<a name="line-162"></a>@
<a name="line-163"></a>
<a name="line-164"></a>The 1st law states that you can't change the shape of the structure or do anything funny with elements (traverse elements which aren't in the structure, create new elements out of thin air, etc.). The 2nd law states that you should be able to fuse 2 identical traversals into one. For a more detailed explanation of the laws, see &lt;<a href="http://artyom.me/lens-over-tea-2#traversal-laws">http://artyom.me/lens-over-tea-2#traversal-laws</a> this blog post&gt; (if you prefer rambling blog posts), or &lt;https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf The Essence Of The Iterator Pattern&gt; (if you prefer papers).
<a name="line-165"></a>-}</span>
<a name="line-166"></a><a name="Traversal"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Traversal</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>f</span><span class='hs-varop'>.</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>t</span>
<a name="line-167"></a>
<a name="line-168"></a><a name="Traversal'"></a><span class='hs-comment'>{- |
<a name="line-169"></a>This is a type alias for monomorphic traversals which don't change the type of the container (or of the values inside).
<a name="line-170"></a>-}</span>
<a name="line-171"></a><a name="Traversal'"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Traversal'</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Traversal</span> <span class='hs-varid'>s</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a</span>
</pre></body>
</html>
