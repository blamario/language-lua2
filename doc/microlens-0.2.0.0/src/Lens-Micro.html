<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Lens/Micro.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE
<a name="line-2"></a>CPP,
<a name="line-3"></a>FlexibleInstances,
<a name="line-4"></a>FlexibleContexts,
<a name="line-5"></a>UndecidableInstances,
<a name="line-6"></a>RankNTypes,
<a name="line-7"></a>ScopedTypeVariables
<a name="line-8"></a>  #-}</span>
<a name="line-9"></a>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Micro</span>
<a name="line-12"></a><span class='hs-layout'>(</span>
<a name="line-13"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>&amp;</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-14"></a>  <span class='hs-comment'>-- $ampersand-note</span>
<a name="line-15"></a>
<a name="line-16"></a>  <span class='hs-comment'>-- * Setting (applying a function to values)</span>
<a name="line-17"></a>  <span class='hs-conid'>ASetter</span><span class='hs-layout'>,</span> <span class='hs-conid'>ASetter'</span><span class='hs-layout'>,</span>
<a name="line-18"></a>  <span class='hs-varid'>sets</span><span class='hs-layout'>,</span>
<a name="line-19"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>%~</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>over</span><span class='hs-layout'>,</span>
<a name="line-20"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>.~</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>set</span><span class='hs-layout'>,</span>
<a name="line-21"></a>  <span class='hs-varid'>mapped</span><span class='hs-layout'>,</span>
<a name="line-22"></a>
<a name="line-23"></a>  <span class='hs-comment'>-- * Getting (retrieving a value)</span>
<a name="line-24"></a>  <span class='hs-comment'>-- $getters-note</span>
<a name="line-25"></a>  <span class='hs-conid'>Getting</span><span class='hs-layout'>,</span>
<a name="line-26"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>^.</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-27"></a>
<a name="line-28"></a>  <span class='hs-comment'>-- * Folds (getters returning multiple elements)</span>
<a name="line-29"></a>  <span class='hs-comment'>-- $folds-note</span>
<a name="line-30"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>^..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-31"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>^?</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-32"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>^?!</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-33"></a>  <span class='hs-varid'>folded</span><span class='hs-layout'>,</span>
<a name="line-34"></a>  <span class='hs-varid'>has</span><span class='hs-layout'>,</span>
<a name="line-35"></a>
<a name="line-36"></a>  <span class='hs-comment'>-- * Lenses (setters and getters at once)</span>
<a name="line-37"></a>  <span class='hs-conid'>Lens</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lens'</span><span class='hs-layout'>,</span>
<a name="line-38"></a>  <span class='hs-varid'>lens</span><span class='hs-layout'>,</span>
<a name="line-39"></a>  <span class='hs-varid'>at</span><span class='hs-layout'>,</span>
<a name="line-40"></a>  <span class='hs-sel'>_1</span><span class='hs-layout'>,</span> <span class='hs-sel'>_2</span><span class='hs-layout'>,</span> <span class='hs-sel'>_3</span><span class='hs-layout'>,</span> <span class='hs-sel'>_4</span><span class='hs-layout'>,</span> <span class='hs-sel'>_5</span><span class='hs-layout'>,</span>
<a name="line-41"></a>
<a name="line-42"></a>  <span class='hs-comment'>-- * Traversals (lenses iterating over several elements)</span>
<a name="line-43"></a>  <span class='hs-conid'>Traversal</span><span class='hs-layout'>,</span> <span class='hs-conid'>Traversal'</span><span class='hs-layout'>,</span>
<a name="line-44"></a>  <span class='hs-varid'>both</span><span class='hs-layout'>,</span>
<a name="line-45"></a>  <span class='hs-varid'>traversed</span><span class='hs-layout'>,</span>
<a name="line-46"></a>  <span class='hs-varid'>each</span><span class='hs-layout'>,</span>
<a name="line-47"></a>  <span class='hs-varid'>ix</span><span class='hs-layout'>,</span>
<a name="line-48"></a>
<a name="line-49"></a>  <span class='hs-comment'>-- * Prisms (traversals iterating over at most 1 element)</span>
<a name="line-50"></a>  <span class='hs-comment'>-- $prisms-note</span>
<a name="line-51"></a>  <span class='hs-sel'>_Left</span><span class='hs-layout'>,</span> <span class='hs-sel'>_Right</span><span class='hs-layout'>,</span>
<a name="line-52"></a>  <span class='hs-sel'>_Just</span><span class='hs-layout'>,</span> <span class='hs-sel'>_Nothing</span><span class='hs-layout'>,</span>
<a name="line-53"></a><span class='hs-layout'>)</span>
<a name="line-54"></a><span class='hs-keyword'>where</span>
<a name="line-55"></a>
<a name="line-56"></a>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Micro</span><span class='hs-varop'>.</span><span class='hs-conid'>Classes</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Micro</span><span class='hs-varop'>.</span><span class='hs-conid'>Type</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Micro</span><span class='hs-varop'>.</span><span class='hs-conid'>Internal</span>
<a name="line-60"></a>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Functor</span><span class='hs-varop'>.</span><span class='hs-conid'>Identity</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Monoid</span>
<a name="line-64"></a>
<a name="line-65"></a><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &gt;= 710</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Function</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>&amp;</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-67"></a><span class='hs-cpp'>#endif</span>
<a name="line-68"></a>
<a name="line-69"></a>
<a name="line-70"></a><span class='hs-comment'>{- $setup
<a name="line-71"></a>-- &gt;&gt;&gt; import Data.Char (toUpper)
<a name="line-72"></a>-- &gt;&gt;&gt; import Control.Arrow (first, second, left, right)
<a name="line-73"></a>-}</span>
<a name="line-74"></a>
<a name="line-75"></a>
<a name="line-76"></a><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &lt; 710</span>
<a name="line-77"></a><a name="&"></a><span class='hs-comment'>{- |
<a name="line-78"></a>'&amp;' is a reverse application operator. This provides notational convenience. Its precedence is one higher than that of the forward application operator '$', which allows '&amp;' to be nested in '$'.
<a name="line-79"></a>-}</span>
<a name="line-80"></a><span class='hs-layout'>(</span><span class='hs-varop'>&amp;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-81"></a><a name="a"></a><span class='hs-definition'>a</span> <span class='hs-varop'>&amp;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-82"></a><span class='hs-comment'>{-# INLINE (&amp;) #-}</span>
<a name="line-83"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>1</span> <span class='hs-varop'>&amp;</span>
<a name="line-84"></a><span class='hs-cpp'>#endif</span>
<a name="line-85"></a>
<a name="line-86"></a><span class='hs-comment'>{- $ampersand-note
<a name="line-87"></a>
<a name="line-88"></a>This operator is useful when you want to modify something several times. For instance, if you want to change 1st and 3rd elements of a tuple, you can write this:
<a name="line-89"></a>
<a name="line-90"></a>@
<a name="line-91"></a>(1,2,3) '&amp;' '_1' '.~' 0
<a name="line-92"></a>        '&amp;' '_3' '%~' 'negate'
<a name="line-93"></a>@
<a name="line-94"></a>
<a name="line-95"></a>instead of e.g. this:
<a name="line-96"></a>
<a name="line-97"></a>@
<a name="line-98"></a>('_1' '.~' 0) '.' ('_3' '%~' 'negate') '$' (1,2,3)
<a name="line-99"></a>@
<a name="line-100"></a>
<a name="line-101"></a>or this:
<a name="line-102"></a>
<a name="line-103"></a>@
<a name="line-104"></a>'set' '_1' 0 '.'
<a name="line-105"></a>'over' '_3' 'negate'
<a name="line-106"></a>  '$' (1,2,3)
<a name="line-107"></a>@
<a name="line-108"></a>-}</span>
<a name="line-109"></a>
<a name="line-110"></a><span class='hs-comment'>-- Setting -----------------------------------------------------------------</span>
<a name="line-111"></a>
<a name="line-112"></a><a name="%25~"></a><span class='hs-comment'>{- |
<a name="line-113"></a>('%~') applies a function to the target; an alternative explanation is that it is an inverse of 'sets', which turns a setter into an ordinary function. @'mapped' '%~' 'reverse'@ is the same thing as @'fmap' 'reverse'@.
<a name="line-114"></a>
<a name="line-115"></a>See 'over' if you want a non-operator synonym.
<a name="line-116"></a>
<a name="line-117"></a>Negating the 1st element of a pair:
<a name="line-118"></a>
<a name="line-119"></a>&gt;&gt;&gt; (1,2) &amp; _1 %~ negate
<a name="line-120"></a>(-1,2)
<a name="line-121"></a>
<a name="line-122"></a>Turning all @Left@s in a list to upper case:
<a name="line-123"></a>
<a name="line-124"></a>&gt;&gt;&gt; (mapped._Left.mapped %~ toUpper) [Left "foo", Right "bar"]
<a name="line-125"></a>[Left "FOO",Right "bar"]
<a name="line-126"></a>-}</span>
<a name="line-127"></a><span class='hs-layout'>(</span><span class='hs-varop'>%~</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ASetter</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span>
<a name="line-128"></a><span class='hs-layout'>(</span><span class='hs-varop'>%~</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>over</span>
<a name="line-129"></a><span class='hs-comment'>{-# INLINE (%~) #-}</span>
<a name="line-130"></a>
<a name="line-131"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>4</span> <span class='hs-varop'>%~</span>
<a name="line-132"></a>
<a name="line-133"></a><a name="over"></a><span class='hs-comment'>{- |
<a name="line-134"></a>'over' is a synonym for ('%~').
<a name="line-135"></a>
<a name="line-136"></a>Getting 'fmap' in a roundabout way:
<a name="line-137"></a>
<a name="line-138"></a>@
<a name="line-139"></a>'over' 'mapped' :: 'Functor' f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
<a name="line-140"></a>'over' 'mapped' = 'fmap'
<a name="line-141"></a>@
<a name="line-142"></a>
<a name="line-143"></a>Applying a function to both components of a pair:
<a name="line-144"></a>
<a name="line-145"></a>@
<a name="line-146"></a>'over' 'both' :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)
<a name="line-147"></a>'over' 'both' = \\f t -&gt; (f (fst t), f (snd t))
<a name="line-148"></a>@
<a name="line-149"></a>
<a name="line-150"></a>Using @'over' '_2'@ as a replacement for 'Control.Arrow.second':
<a name="line-151"></a>
<a name="line-152"></a>&gt;&gt;&gt; over _2 show (10,20)
<a name="line-153"></a>(10,"20")
<a name="line-154"></a>-}</span>
<a name="line-155"></a><span class='hs-definition'>over</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ASetter</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span>
<a name="line-156"></a><span class='hs-definition'>over</span> <span class='hs-varid'>l</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runIdentity</span> <span class='hs-varop'>.</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conid'>Identity</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-157"></a><span class='hs-comment'>{-# INLINE over #-}</span>
<a name="line-158"></a>
<a name="line-159"></a><a name=".~"></a><span class='hs-comment'>{- |
<a name="line-160"></a>('.~') assigns a value to the target. These are equivalent:
<a name="line-161"></a>
<a name="line-162"></a>* @l '.~' x@
<a name="line-163"></a>* @l '%~' 'const' x@
<a name="line-164"></a>
<a name="line-165"></a>See 'set' if you want a non-operator synonym.
<a name="line-166"></a>
<a name="line-167"></a>Here it is used to change 2 fields of a 3-tuple:
<a name="line-168"></a>
<a name="line-169"></a>&gt;&gt;&gt; (0,0,0) &amp; _1 .~ 1 &amp; _3 .~ 3
<a name="line-170"></a>(1,0,3)
<a name="line-171"></a>-}</span>
<a name="line-172"></a><span class='hs-layout'>(</span><span class='hs-varop'>.~</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ASetter</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span>
<a name="line-173"></a><span class='hs-layout'>(</span><span class='hs-varop'>.~</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>set</span>
<a name="line-174"></a><span class='hs-comment'>{-# INLINE (.~) #-}</span>
<a name="line-175"></a>
<a name="line-176"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>4</span> <span class='hs-varop'>.~</span>
<a name="line-177"></a>
<a name="line-178"></a><a name="set"></a><span class='hs-comment'>{- |
<a name="line-179"></a>'set' is a synonym for ('.~').
<a name="line-180"></a>
<a name="line-181"></a>Setting the 1st component of a pair:
<a name="line-182"></a>
<a name="line-183"></a>@
<a name="line-184"></a>'set' '_1' :: x -&gt; (a, b) -&gt; (x, b)
<a name="line-185"></a>'set' '_1' = \\x t -&gt; (x, snd t)
<a name="line-186"></a>@
<a name="line-187"></a>
<a name="line-188"></a>Using it to rewrite ('Data.Functor.&lt;$'):
<a name="line-189"></a>
<a name="line-190"></a>@
<a name="line-191"></a>'set' 'mapped' :: 'Functor' f =&gt; a -&gt; f b -&gt; f a
<a name="line-192"></a>'set' 'mapped' = ('Data.Functor.&lt;$')
<a name="line-193"></a>@
<a name="line-194"></a>-}</span>
<a name="line-195"></a><span class='hs-definition'>set</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ASetter</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span>
<a name="line-196"></a><span class='hs-definition'>set</span> <span class='hs-varid'>l</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runIdentity</span> <span class='hs-varop'>.</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Identity</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-197"></a><span class='hs-comment'>{-# INLINE set #-}</span>
<a name="line-198"></a>
<a name="line-199"></a><a name="mapped"></a><span class='hs-comment'>{- |
<a name="line-200"></a>'mapped' is a setter for everything contained in a functor. You can use it to map over lists, @Maybe@, or even @IO@ (which is something you can't do with 'traversed' or 'each').
<a name="line-201"></a>
<a name="line-202"></a>Here 'mapped' is used to turn a value to all non-'Nothing' values in a list:
<a name="line-203"></a>
<a name="line-204"></a>&gt;&gt;&gt; [Just 3,Nothing,Just 5] &amp; mapped.mapped .~ 0
<a name="line-205"></a>[Just 0,Nothing,Just 0]
<a name="line-206"></a>
<a name="line-207"></a>Keep in mind that while 'mapped' is a more powerful setter than 'each', it can't be used as a getter! This won't work (and will fail with a type error):
<a name="line-208"></a>
<a name="line-209"></a>@
<a name="line-210"></a>[(1,2),(3,4),(5,6)] '^..' 'mapped' . 'both'
<a name="line-211"></a>@
<a name="line-212"></a>-}</span>
<a name="line-213"></a><span class='hs-definition'>mapped</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ASetter</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
<a name="line-214"></a><span class='hs-definition'>mapped</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sets</span> <span class='hs-varid'>fmap</span>
<a name="line-215"></a><span class='hs-comment'>{-# INLINE mapped #-}</span>
<a name="line-216"></a>
<a name="line-217"></a><span class='hs-comment'>-- Getting -----------------------------------------------------------------</span>
<a name="line-218"></a>
<a name="line-219"></a><span class='hs-comment'>{- $getters-note
<a name="line-220"></a>
<a name="line-221"></a>Getters are a not-entirely-obvious way to use lenses to /carry out/ information from a structure (instead of changing something inside the structure). Any lens or traversal is a getter.
<a name="line-222"></a>
<a name="line-223"></a>For details, see the documentation for 'Getting'.
<a name="line-224"></a>
<a name="line-225"></a>Including @&lt;<a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Getter">http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Getter</a> Getter&gt;@ is impossible, as then this package would have to depend on &lt;<a href="http://hackage.haskell.org/package/contravariant">http://hackage.haskell.org/package/contravariant</a> contravariant&gt; and it's a big dependency.
<a name="line-226"></a>-}</span>
<a name="line-227"></a>
<a name="line-228"></a><a name="%5e."></a><span class='hs-comment'>{- |
<a name="line-229"></a>('^.') applies a getter to a value; in other words, it gets a value out of a structure using a getter (which can be a lens, traversal, fold, etc.).
<a name="line-230"></a>
<a name="line-231"></a>Getting 1st field of a tuple:
<a name="line-232"></a>
<a name="line-233"></a>@
<a name="line-234"></a>('^.' '_1') :: (a, b) -&gt; a
<a name="line-235"></a>('^.' '_1') = 'fst'
<a name="line-236"></a>@
<a name="line-237"></a>
<a name="line-238"></a>When ('^.') is used with a traversal, it combines all results using the 'Monoid' instance for the resulting type. For instance, for lists it would be simple concatenation:
<a name="line-239"></a>
<a name="line-240"></a>&gt;&gt;&gt; ("str","ing") ^. each
<a name="line-241"></a>"string"
<a name="line-242"></a>
<a name="line-243"></a>The reason for this is that traversals use 'Applicative', and the 'Applicative' instance for 'Const' uses monoid concatenation to combine “effects” of 'Const'.
<a name="line-244"></a>-}</span>
<a name="line-245"></a><span class='hs-layout'>(</span><span class='hs-varop'>^.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Getting</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-246"></a><a name="s"></a><span class='hs-definition'>s</span> <span class='hs-varop'>^.</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getConst</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-conid'>Const</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-247"></a><span class='hs-comment'>{-# INLINE (^.) #-}</span>
<a name="line-248"></a>
<a name="line-249"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>8</span> <span class='hs-varop'>^.</span>
<a name="line-250"></a>
<a name="line-251"></a><span class='hs-comment'>-- Folds -------------------------------------------------------------------</span>
<a name="line-252"></a>
<a name="line-253"></a><span class='hs-comment'>{- $folds-note
<a name="line-254"></a>
<a name="line-255"></a>Folds are getters that can traverse more than one element (or no elements at all). The only fold here which isn't simultaneously a 'Traversal' is 'folded' (traversals are folds that also can modify elements they're traversing).
<a name="line-256"></a>
<a name="line-257"></a>You can apply folds to values by using operators like ('^..'), ('^?'), etc:
<a name="line-258"></a>
<a name="line-259"></a>&gt;&gt;&gt; (1,2) ^.. both
<a name="line-260"></a>[1,2]
<a name="line-261"></a>
<a name="line-262"></a>A nice thing about folds is that you can combine them with ('Data.Monoid.&lt;&gt;') to concatenate their outputs:
<a name="line-263"></a>
<a name="line-264"></a>&gt;&gt;&gt; (1,2,3) ^.. (_2 &lt;&gt; _1)  -- in reversed order because why not
<a name="line-265"></a>[2,1]
<a name="line-266"></a>
<a name="line-267"></a>You can build more complicated getters with it when 'each' would be unhelpful:
<a name="line-268"></a>
<a name="line-269"></a>&gt;&gt;&gt; ([1,2], 3, [Nothing, Just 4]) ^.. (_1.each &lt;&gt; _2 &lt;&gt; _3.each._Just)
<a name="line-270"></a>[1,2,3,4]
<a name="line-271"></a>
<a name="line-272"></a>It plays nicely with ('^?'), too:
<a name="line-273"></a>
<a name="line-274"></a>&gt;&gt;&gt; [0..9] ^? (ix 9 &lt;&gt; ix 5)
<a name="line-275"></a>Just 9
<a name="line-276"></a>&gt;&gt;&gt; [0..8] ^? (ix 9 &lt;&gt; ix 5)
<a name="line-277"></a>Just 5
<a name="line-278"></a>&gt;&gt;&gt; [0..3] ^? (ix 9 &lt;&gt; ix 5)
<a name="line-279"></a>Nothing
<a name="line-280"></a>
<a name="line-281"></a>(Unfortunately, this trick won't help you with setting or modifying.)
<a name="line-282"></a>-}</span>
<a name="line-283"></a>
<a name="line-284"></a><a name="%5e.."></a><span class='hs-comment'>{- |
<a name="line-285"></a>@s ^.. t@ returns the list of all values that @t@ gets from @s@.
<a name="line-286"></a>
<a name="line-287"></a>A 'Maybe' contains either 0 or 1 values:
<a name="line-288"></a>
<a name="line-289"></a>&gt;&gt;&gt; Just 3 ^.. _Just
<a name="line-290"></a>[3]
<a name="line-291"></a>
<a name="line-292"></a>Gathering all values in a list of tuples:
<a name="line-293"></a>
<a name="line-294"></a>&gt;&gt;&gt; [(1,2),(3,4)] ^.. each.each
<a name="line-295"></a>[1,2,3,4]
<a name="line-296"></a>-}</span>
<a name="line-297"></a><span class='hs-layout'>(</span><span class='hs-varop'>^..</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Getting</span> <span class='hs-layout'>(</span><span class='hs-conid'>Endo</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-298"></a><span class='hs-definition'>s</span> <span class='hs-varop'>^..</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrOf</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>s</span>
<a name="line-299"></a><span class='hs-comment'>{-# INLINE (^..) #-}</span>
<a name="line-300"></a>
<a name="line-301"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>8</span> <span class='hs-varop'>^..</span>
<a name="line-302"></a>
<a name="line-303"></a><a name="%5e?"></a><span class='hs-comment'>{- |
<a name="line-304"></a>@s ^? t@ returns the 1st element @t@ returns, or 'Nothing' if @t@ doesn't return anything. It's trivially implemented by passing the 'First' monoid to the getter.
<a name="line-305"></a>
<a name="line-306"></a>Safe 'head':
<a name="line-307"></a>
<a name="line-308"></a>&gt;&gt;&gt; [] ^? each
<a name="line-309"></a>Nothing
<a name="line-310"></a>
<a name="line-311"></a>&gt;&gt;&gt; [1..3] ^? each
<a name="line-312"></a>Just 1
<a name="line-313"></a>
<a name="line-314"></a>Converting 'Either' to 'Maybe':
<a name="line-315"></a>
<a name="line-316"></a>&gt;&gt;&gt; Left 1 ^? _Right
<a name="line-317"></a>Nothing
<a name="line-318"></a>
<a name="line-319"></a>&gt;&gt;&gt; Right 1 ^? _Right
<a name="line-320"></a>Just 1
<a name="line-321"></a>-}</span>
<a name="line-322"></a><span class='hs-layout'>(</span><span class='hs-varop'>^?</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Getting</span> <span class='hs-layout'>(</span><span class='hs-conid'>First</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>
<a name="line-323"></a><span class='hs-definition'>s</span> <span class='hs-varop'>^?</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFirst</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldMapOf</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-conid'>First</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Just</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-324"></a><span class='hs-comment'>{-# INLINE (^?) #-}</span>
<a name="line-325"></a>
<a name="line-326"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>8</span> <span class='hs-varop'>^?</span>
<a name="line-327"></a>
<a name="line-328"></a><a name="%5e?!"></a><span class='hs-comment'>{- |
<a name="line-329"></a>('^?!') is an unsafe variant of ('^?') – instead of using 'Nothing' to indicate that there were no elements returned, it throws an exception.
<a name="line-330"></a>-}</span>
<a name="line-331"></a><span class='hs-layout'>(</span><span class='hs-varop'>^?!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Getting</span> <span class='hs-layout'>(</span><span class='hs-conid'>Endo</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-332"></a><span class='hs-definition'>s</span> <span class='hs-varop'>^?!</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrOf</span> <span class='hs-varid'>l</span> <span class='hs-varid'>const</span> <span class='hs-layout'>(</span><span class='hs-varid'>error</span> <span class='hs-str'>"(^?!): empty Fold"</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span>
<a name="line-333"></a><span class='hs-comment'>{-# INLINE (^?!) #-}</span>
<a name="line-334"></a>
<a name="line-335"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>8</span> <span class='hs-varop'>^?!</span>
<a name="line-336"></a>
<a name="line-337"></a><a name="has"></a><span class='hs-comment'>{- |
<a name="line-338"></a>'has' checks whether a getter (any getter, including lenses, traversals, and folds) returns at least 1 value.
<a name="line-339"></a>
<a name="line-340"></a>Checking whether a list is non-empty:
<a name="line-341"></a>
<a name="line-342"></a>&gt;&gt;&gt; has each []
<a name="line-343"></a>False
<a name="line-344"></a>
<a name="line-345"></a>You can also use it with e.g. '_Left' (and other 0-or-1 traversals) as a replacement for 'Data.Maybe.isNothing', 'Data.Maybe.isJust' and other @isConstructorName@ functions:
<a name="line-346"></a>
<a name="line-347"></a>&gt;&gt;&gt; has _Left (Left 1)
<a name="line-348"></a>True
<a name="line-349"></a>-}</span>
<a name="line-350"></a><span class='hs-definition'>has</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Getting</span> <span class='hs-conid'>Any</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-351"></a><span class='hs-definition'>has</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getAny</span> <span class='hs-varop'>.</span> <span class='hs-varid'>foldMapOf</span> <span class='hs-varid'>l</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Any</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-352"></a><span class='hs-comment'>{-# INLINE has #-}</span>
<a name="line-353"></a>
<a name="line-354"></a><span class='hs-comment'>-- Lenses ------------------------------------------------------------------</span>
<a name="line-355"></a>
<a name="line-356"></a><a name="lens"></a><span class='hs-comment'>{- |
<a name="line-357"></a>'lens' creates a 'Lens' from a getter and a setter. The resulting lens isn't the most effective one (because of having to traverse the structure twice when modifying), but it shouldn't matter much.
<a name="line-358"></a>
<a name="line-359"></a>A (partial) lens for list indexing:
<a name="line-360"></a>
<a name="line-361"></a>@
<a name="line-362"></a>ix :: Int -&gt; 'Lens'' [a] a
<a name="line-363"></a>ix i = 'lens' ('!!' i)                                   -- getter
<a name="line-364"></a>            (\\s b -&gt; take i s ++ b : drop (i+1) s)   -- setter
<a name="line-365"></a>@
<a name="line-366"></a>
<a name="line-367"></a>Usage:
<a name="line-368"></a>
<a name="line-369"></a>@
<a name="line-370"></a>&gt;&gt;&gt; [1..9] '^.' ix 3
<a name="line-371"></a>4
<a name="line-372"></a>
<a name="line-373"></a>&gt;&gt;&gt; [1..9] &amp; ix 3 '%~' negate
<a name="line-374"></a>[1,2,3,-4,5,6,7,8,9]
<a name="line-375"></a>@
<a name="line-376"></a>
<a name="line-377"></a>When getting, the setter is completely unused; when setting, the getter is unused. Both are used only when the value is being modified. For instance, here we define a lens for the 1st element of a list, but instead of a legitimate getter we use 'undefined'. Then we use the resulting lens for /setting/ and it works, which proves that the getter wasn't used:
<a name="line-378"></a>
<a name="line-379"></a>&gt;&gt;&gt; [1,2,3] &amp; lens undefined (\s b -&gt; b : tail s) .~ 10
<a name="line-380"></a>[10,2,3]
<a name="line-381"></a>-}</span>
<a name="line-382"></a><span class='hs-definition'>lens</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Lens</span> <span class='hs-varid'>s</span> <span class='hs-varid'>t</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
<a name="line-383"></a><span class='hs-definition'>lens</span> <span class='hs-varid'>sa</span> <span class='hs-varid'>sbt</span> <span class='hs-varid'>afb</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sbt</span> <span class='hs-varid'>s</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>afb</span> <span class='hs-layout'>(</span><span class='hs-varid'>sa</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-384"></a><span class='hs-comment'>{-# INLINE lens #-}</span>
<a name="line-385"></a>
<a name="line-386"></a><span class='hs-comment'>-- Traversals --------------------------------------------------------------</span>
<a name="line-387"></a>
<a name="line-388"></a><a name="both"></a><span class='hs-comment'>{- |
<a name="line-389"></a>'both' traverses both fields of a tuple. Unlike @&lt;<a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:both">http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:both</a> both&gt;@ from lens, it only works for pairs – not for triples or 'Either'.
<a name="line-390"></a>
<a name="line-391"></a>&gt;&gt;&gt; ("str","ing") ^. both
<a name="line-392"></a>"string"
<a name="line-393"></a>
<a name="line-394"></a>&gt;&gt;&gt; ("str","ing") &amp; both %~ reverse
<a name="line-395"></a>("rts","gni")
<a name="line-396"></a>-}</span>
<a name="line-397"></a><span class='hs-definition'>both</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Traversal</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
<a name="line-398"></a><span class='hs-definition'>both</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>liftA2</span> <span class='hs-conid'>(,)</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-399"></a><span class='hs-comment'>{-# INLINE both #-}</span>
<a name="line-400"></a>
<a name="line-401"></a><span class='hs-comment'>-- Prisms ------------------------------------------------------------------</span>
<a name="line-402"></a>
<a name="line-403"></a><span class='hs-comment'>{- $prisms-note
<a name="line-404"></a>
<a name="line-405"></a>Prisms are traversals that always target 0 or 1 values. Moreover, it's possible to /reverse/ a prism, using it to construct a structure instead of peeking into it. Here's an example from the lens library:
<a name="line-406"></a>
<a name="line-407"></a>@
<a name="line-408"></a>&gt;&gt;&gt; over _Left (+1) (Left 2)
<a name="line-409"></a>Left 3
<a name="line-410"></a>
<a name="line-411"></a>&gt;&gt;&gt; _Left # 5
<a name="line-412"></a>Left 5
<a name="line-413"></a>@
<a name="line-414"></a>
<a name="line-415"></a>However, it's not possible for microlens to export prisms, because their type depends on @&lt;<a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#t:Choice">http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#t:Choice</a> Choice&gt;@, which resides in the &lt;<a href="http://hackage.haskell.org/package/profunctors">http://hackage.haskell.org/package/profunctors</a> profunctors&gt; library, which is a somewhat huge dependency. So, all prisms included here are traversals instead.
<a name="line-416"></a>-}</span>
<a name="line-417"></a>
<a name="line-418"></a><span class='hs-comment'>{- |
<a name="line-419"></a>'_Left' targets the value contained in an 'Either', provided it's a 'Left'.
<a name="line-420"></a>
<a name="line-421"></a>Gathering all @Left@s in a structure (like the 'Data.Either.lefts' function, but not necessarily just for lists):
<a name="line-422"></a>
<a name="line-423"></a>&gt;&gt;&gt; [Left 1, Right 'c', Left 3] ^.. each._Just
<a name="line-424"></a>[1,3]
<a name="line-425"></a>
<a name="line-426"></a>Checking whether an 'Either' is a 'Left' (like 'Data.Either.isLeft'):
<a name="line-427"></a>
<a name="line-428"></a>&gt;&gt;&gt; has _Left (Left 1)
<a name="line-429"></a>True
<a name="line-430"></a>
<a name="line-431"></a>&gt;&gt;&gt; has _Left (Right 1)
<a name="line-432"></a>False
<a name="line-433"></a>
<a name="line-434"></a>Extracting a value (if you're sure it's a 'Left'):
<a name="line-435"></a>
<a name="line-436"></a>&gt;&gt;&gt; Left 1 ^?! _Left
<a name="line-437"></a>1
<a name="line-438"></a>
<a name="line-439"></a>Mapping over all 'Left's:
<a name="line-440"></a>
<a name="line-441"></a>&gt;&gt;&gt; (each._Left %~ map toUpper) [Left "foo", Right "bar"]
<a name="line-442"></a>[Left "FOO",Right "bar"]
<a name="line-443"></a>
<a name="line-444"></a>Implementation:
<a name="line-445"></a>
<a name="line-446"></a>@
<a name="line-447"></a>'_Left' f (Left a)  = 'Left' '&lt;$&gt;' f a
<a name="line-448"></a>'_Left' _ (Right b) = 'pure' ('Right' b)
<a name="line-449"></a>@
<a name="line-450"></a>-}</span>
<a name="line-451"></a><span class='hs-sel'>_Left</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Traversal</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a'</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a'</span>
<a name="line-452"></a><span class='hs-sel'>_Left</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-453"></a><span class='hs-sel'>_Left</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-454"></a><span class='hs-comment'>{-# INLINE _Left #-}</span>
<a name="line-455"></a>
<a name="line-456"></a><span class='hs-comment'>{- |
<a name="line-457"></a>'_Right' targets the value contained in an 'Either', provided it's a 'Right'.
<a name="line-458"></a>
<a name="line-459"></a>See documentation for '_Left'.
<a name="line-460"></a>-}</span>
<a name="line-461"></a><span class='hs-sel'>_Right</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Traversal</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-varid'>b'</span>
<a name="line-462"></a><span class='hs-sel'>_Right</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-463"></a><span class='hs-sel'>_Right</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-464"></a><span class='hs-comment'>{-# INLINE _Right #-}</span>
<a name="line-465"></a>
<a name="line-466"></a><span class='hs-comment'>{- |
<a name="line-467"></a>'_Just' targets the value contained in a 'Maybe', provided it's a 'Just'.
<a name="line-468"></a>
<a name="line-469"></a>See documentation for '_Left' (as these 2 are pretty similar). In particular, it can be used to write these:
<a name="line-470"></a>
<a name="line-471"></a>  * Unsafely extracting a value from a 'Just':
<a name="line-472"></a>
<a name="line-473"></a>    @
<a name="line-474"></a>    'Data.Maybe.fromJust' = ('^?!' '_Just')
<a name="line-475"></a>    @
<a name="line-476"></a>
<a name="line-477"></a>  * Checking whether a value is a 'Just':
<a name="line-478"></a>
<a name="line-479"></a>    @
<a name="line-480"></a>    'Data.Maybe.isJust' = 'has' '_Just'
<a name="line-481"></a>    @
<a name="line-482"></a>
<a name="line-483"></a>  * Converting a 'Maybe' to a list (empty or consisting of a single element):
<a name="line-484"></a>
<a name="line-485"></a>    @
<a name="line-486"></a>    'Data.Maybe.maybeToList' = ('^..' '_Just')
<a name="line-487"></a>    @
<a name="line-488"></a>
<a name="line-489"></a>  * Gathering all 'Just's in a list:
<a name="line-490"></a>
<a name="line-491"></a>    @
<a name="line-492"></a>    'Data.Maybe.catMaybes' = ('^..' 'each' '.' '_Just')
<a name="line-493"></a>    @
<a name="line-494"></a>-}</span>
<a name="line-495"></a><span class='hs-sel'>_Just</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Traversal</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a'</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a'</span>
<a name="line-496"></a><span class='hs-sel'>_Just</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-497"></a><span class='hs-sel'>_Just</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>Nothing</span>
<a name="line-498"></a><span class='hs-comment'>{-# INLINE _Just #-}</span>
<a name="line-499"></a>
<a name="line-500"></a><span class='hs-comment'>{- |
<a name="line-501"></a>'_Nothing' targets a @()@ if the 'Maybe' is a 'Nothing', and doesn't target anything otherwise:
<a name="line-502"></a>
<a name="line-503"></a>&gt;&gt;&gt; Just 1 ^.. _Nothing
<a name="line-504"></a>[]
<a name="line-505"></a>
<a name="line-506"></a>&gt;&gt;&gt; Nothing ^.. _Nothing
<a name="line-507"></a>[()]
<a name="line-508"></a>
<a name="line-509"></a>It's not particularly useful (unless you want to use @'has' '_Nothing'@ as a replacement for 'Data.Maybe.isNothing'), and provided mainly for consistency.
<a name="line-510"></a>
<a name="line-511"></a>Implementation:
<a name="line-512"></a>
<a name="line-513"></a>@
<a name="line-514"></a>'_Nothing' f Nothing = 'const' 'Nothing' '&lt;$&gt;' f ()
<a name="line-515"></a>'_Nothing' _ j       = 'pure' j
<a name="line-516"></a>@
<a name="line-517"></a>-}</span>
<a name="line-518"></a><span class='hs-sel'>_Nothing</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Traversal'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-conid'>()</span>
<a name="line-519"></a><span class='hs-sel'>_Nothing</span> <span class='hs-varid'>f</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>const</span> <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span>
<a name="line-520"></a><span class='hs-sel'>_Nothing</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>j</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>j</span>
<a name="line-521"></a><span class='hs-comment'>{-# INLINE _Nothing #-}</span>
</pre></body>
</html>
