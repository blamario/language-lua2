-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lua parser and pretty printer
--   
--   Lua parser and pretty printer
@package language-lua
@version 0.1.0.0


-- | Lua pretty-printing re-exports. All AST nodes are instances of
--   <a>Pretty</a>; this module just re-exports types and top-level
--   rendering functions from <a>wl-pprint</a>.
module Language.Lua.Pretty

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 100
--   characters and a ribbon width of 40 characters.
--   
--   <pre>
--   show (text "hello" &lt;$&gt; text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc :: *

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc
prettyList :: Pretty a => [a] -> Doc

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc :: *
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: UnpkInt -> String -> SimpleDoc -> SimpleDoc
SLine :: UnpkInt -> SimpleDoc -> SimpleDoc

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
renderCompact :: Doc -> SimpleDoc

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
displayS :: SimpleDoc -> ShowS

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 100 doc)
--   </pre>
displayIO :: Handle -> SimpleDoc -> IO ()


-- | Abstract syntax of Lua 5.3 source files. See
--   <a>http://www.lua.org/manual/5.3/</a> for more information.
module Language.Lua.Syntax

-- | An identifier, defined as any string of letters, digits, or
--   underscores, not beginning with a digit.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.1</a>
data Ident a
Ident :: !a -> !String -> Ident a

-- | One or more <a>Ident</a>s.
data IdentList1 a
IdentList1 :: !a -> !(NonEmpty (Ident a)) -> IdentList1 a

-- | A chunk; Lua's compilation unit.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.3.2</a>
type Chunk = Block

-- | A block of statements, possibly ending in a return statement.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.3.1</a>
data Block a
Block :: !a -> ![Statement a] -> !(Maybe (ReturnStatement a)) -> Block a

-- | A statement.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.3</a>
data Statement a

-- | <pre>
--   ;
--   </pre>
EmptyStmt :: !a -> Statement a

-- | <pre>
--   <i>var1</i>, <i>var2</i>, <i>var3</i> = <i>exp1</i>, <i>exp2</i>, <i>exp3</i>
--   </pre>
Assign :: !a -> !(VariableList1 a) -> !(ExpressionList1 a) -> Statement a

-- | <pre>
--   foo.bar(<i>args</i>)
--   </pre>
FunCall :: !a -> !(FunctionCall a) -> Statement a

-- | <pre>
--   ::label::
--   </pre>
Label :: !a -> !(Ident a) -> Statement a

-- | <pre>
--   <b>break</b>
--   </pre>
Break :: !a -> Statement a

-- | <pre>
--   <b>goto</b> label
--   </pre>
Goto :: !a -> !(Ident a) -> Statement a

-- | <pre>
--   <b>do</b> <i>block</i> <b>end</b>
--   </pre>
Do :: !a -> !(Block a) -> Statement a

-- | <pre>
--   <b>while</b> <i>exp</i> <b>do</b> <i>block</i> <b>end</b>
--   </pre>
While :: !a -> !(Expression a) -> !(Block a) -> Statement a

-- | <pre>
--   <b>repeat</b> <i>block</i> <b>until</b> <i>exp</i>
--   </pre>
Repeat :: !a -> !(Block a) -> !(Expression a) -> Statement a

-- | <pre>
--   <b>if</b> <i>exp</i> <b>then</b> <i>block</i> <b>else</b> <i>block</i> <b>end</b>
--   </pre>
If :: !a -> !(NonEmpty (Expression a, Block a)) -> !(Maybe (Block a)) -> Statement a

-- | <pre>
--   <b>for</b> x = <i>exp</i> <b>do</b> <i>block</i> <b>end</b>
--   </pre>
For :: !a -> !(Ident a) -> !(Expression a) -> !(Expression a) -> !(Maybe (Expression a)) -> !(Block a) -> Statement a

-- | <pre>
--   <b>for</b> a, b, c <b>in</b> <i>exp1</i>, <i>exp2</i>, <i>exp3</i> <b>do</b> <i>block</i> <b>end</b>
--   </pre>
ForIn :: !a -> !(IdentList1 a) -> !(ExpressionList1 a) -> !(Block a) -> Statement a

-- | <pre>
--   <b>function</b> name <i>body</i>
--   </pre>
FunAssign :: !a -> !(FunctionName a) -> !(FunctionBody a) -> Statement a

-- | <pre>
--   <b>local function</b> name <i>body</i>
--   </pre>
LocalFunAssign :: !a -> !(Ident a) -> !(FunctionBody a) -> Statement a

-- | <pre>
--   <b>local</b> x, y, z
--   </pre>
LocalAssign :: !a -> !(IdentList1 a) -> !(ExpressionList a) -> Statement a
data ReturnStatement a

-- | <pre>
--   <b>return</b> <i>exp1</i>, <i>exp2</i>
--   </pre>
ReturnStatement :: !a -> !(ExpressionList a) -> ReturnStatement a
data FunctionName a

-- | <pre>
--   foo.bar:baz
--   </pre>
FunctionName :: !a -> !(IdentList1 a) -> !(Maybe (Ident a)) -> FunctionName a

-- | A variable.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.2</a>
data Variable a

-- | <pre>
--   x
--   </pre>
VarIdent :: !a -> !(Ident a) -> Variable a

-- | <pre>
--   <i>table</i>[<i>exp</i>]
--   </pre>
VarField :: !a -> !(PrefixExpression a) -> !(Expression a) -> Variable a

-- | <pre>
--   <i>table</i>.field
--   </pre>
VarFieldName :: !a -> !(PrefixExpression a) -> !(Ident a) -> Variable a

-- | One or more <a>Variable</a>s.
data VariableList1 a
VariableList1 :: !a -> !(NonEmpty (Variable a)) -> VariableList1 a

-- | An expression.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.4</a>
data Expression a
Nil :: !a -> Expression a
Bool :: !a -> !Bool -> Expression a
Integer :: !a -> !String -> Expression a
Float :: !a -> !String -> Expression a
String :: !a -> !String -> Expression a
Vararg :: !a -> Expression a
FunDef :: !a -> !(FunctionBody a) -> Expression a
PrefixExp :: !a -> !(PrefixExpression a) -> Expression a
TableCtor :: !a -> !(TableConstructor a) -> Expression a
Binop :: !a -> !(Binop a) -> !(Expression a) -> !(Expression a) -> Expression a
Unop :: !a -> !(Unop a) -> !(Expression a) -> Expression a

-- | Zero or more <a>Expression</a>s.
data ExpressionList a
ExpressionList :: !a -> ![Expression a] -> ExpressionList a

-- | One or more <a>Expression</a>s.
data ExpressionList1 a
ExpressionList1 :: !a -> !(NonEmpty (Expression a)) -> ExpressionList1 a
data PrefixExpression a
PrefixVar :: !a -> !(Variable a) -> PrefixExpression a
PrefixFunCall :: !a -> !(FunctionCall a) -> PrefixExpression a
Parens :: !a -> !(Expression a) -> PrefixExpression a

-- | A function call. May be a statement or an expression.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.3.6</a>
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.4.10</a>
data FunctionCall a
FunctionCall :: !a -> !(PrefixExpression a) -> !(FunctionArgs a) -> FunctionCall a
MethodCall :: !a -> !(PrefixExpression a) -> !(Ident a) -> !(FunctionArgs a) -> FunctionCall a
data FunctionArgs a

-- | <pre>
--   (<i>exp1</i>, <i>exp2</i>)
--   </pre>
Args :: !a -> !(ExpressionList a) -> FunctionArgs a

-- | <pre>
--   { x = <i>exp</i> }
--   </pre>
ArgsTable :: !a -> !(TableConstructor a) -> FunctionArgs a

-- | <pre>
--   "str"
--   </pre>
ArgsString :: !a -> !String -> FunctionArgs a
data FunctionBody a

-- | <pre>
--   (x, y, ...) <i>block</i> <b>end</b>
--   </pre>
FunctionBody :: !a -> !(IdentList1 a) -> !Bool -> !(Block a) -> FunctionBody a

-- | <pre>
--   (...) <i>block</i> <b>end</b>
--   </pre>
FunctionBodyVararg :: !a -> !(Block a) -> FunctionBody a

-- | A table constructor.
--   
--   <a>http://www.lua.org/manual/5.3/manual.html#3.4.9</a>
data TableConstructor a

-- | <pre>
--   { x = 5, [f(1)] = 6, 7 }
--   </pre>
TableConstructor :: !a -> !(FieldList a) -> TableConstructor a
data Field a

-- | <pre>
--   [<i>exp1</i>] = <i>exp2</i>
--   </pre>
FieldExp :: !a -> !(Expression a) -> !(Expression a) -> Field a

-- | <pre>
--   name = <i>exp</i>
--   </pre>
FieldIdent :: !a -> !(Ident a) -> !(Expression a) -> Field a

-- | <pre>
--   <i>exp</i>
--   </pre>
Field :: !a -> !(Expression a) -> Field a

-- | Zero or more <a>Field</a>s, separated by <tt>,</tt> or <tt>;</tt>.
data FieldList a
FieldList :: !a -> ![Field a] -> FieldList a
data Binop a

-- | +
Plus :: !a -> Binop a

-- | -
Minus :: !a -> Binop a

-- | *
Mult :: !a -> Binop a

-- | /
FloatDiv :: !a -> Binop a

-- | //
FloorDiv :: !a -> Binop a

-- | ^
Exponent :: !a -> Binop a

-- | %
Modulo :: !a -> Binop a

-- | &amp;
BitwiseAnd :: !a -> Binop a

-- | ~
BitwiseXor :: !a -> Binop a

-- | |
BitwiseOr :: !a -> Binop a

-- | &gt;&gt;
Rshift :: !a -> Binop a

-- | &lt;&lt;
Lshift :: !a -> Binop a

-- | ..
Concat :: !a -> Binop a

-- | &lt;
Lt :: !a -> Binop a

-- | &lt;=
Leq :: !a -> Binop a

-- | &gt;
Gt :: !a -> Binop a

-- | &gt;=
Geq :: !a -> Binop a

-- | ==
Eq :: !a -> Binop a

-- | ~=
Neq :: !a -> Binop a

-- | and
And :: !a -> Binop a

-- | or
Or :: !a -> Binop a
data Unop a

-- | -
Negate :: !a -> Unop a

-- | not
Not :: !a -> Unop a

-- | #
Length :: !a -> Unop a

-- | ~
BitwiseNot :: !a -> Unop a
class Functor ast => Annotated ast
ann :: Annotated ast => Lens' (ast a) a
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0VariableList1
instance GHC.Generics.Datatype Language.Lua.Syntax.D1VariableList1
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0ExpressionList1
instance GHC.Generics.Datatype Language.Lua.Syntax.D1ExpressionList1
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2Variable
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1Variable
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Variable
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Variable
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2PrefixExpression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1PrefixExpression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0PrefixExpression
instance GHC.Generics.Datatype Language.Lua.Syntax.D1PrefixExpression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2FunctionArgs
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1FunctionArgs
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0FunctionArgs
instance GHC.Generics.Datatype Language.Lua.Syntax.D1FunctionArgs
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1FunctionCall
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0FunctionCall
instance GHC.Generics.Datatype Language.Lua.Syntax.D1FunctionCall
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_14Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_13Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_12Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_11Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_10Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_9Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_8Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_7Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_6Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_5Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_4Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_3Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Statement
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Statement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0ExpressionList
instance GHC.Generics.Datatype Language.Lua.Syntax.D1ExpressionList
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0ReturnStatement
instance GHC.Generics.Datatype Language.Lua.Syntax.D1ReturnStatement
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Block
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Block
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1FunctionBody
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0FunctionBody
instance GHC.Generics.Datatype Language.Lua.Syntax.D1FunctionBody
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2Field
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1Field
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Field
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Field
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0FieldList
instance GHC.Generics.Datatype Language.Lua.Syntax.D1FieldList
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0TableConstructor
instance GHC.Generics.Datatype Language.Lua.Syntax.D1TableConstructor
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_10Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_9Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_8Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_7Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_6Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_5Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_4Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_3Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Expression
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Expression
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_3Unop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2Unop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1Unop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Unop
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Unop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_20Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_19Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_18Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_17Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_16Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_15Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_14Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_13Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_12Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_11Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_10Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_9Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_8Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_7Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_6Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_5Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_4Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_3Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_2Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_1Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Binop
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Binop
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0FunctionName
instance GHC.Generics.Datatype Language.Lua.Syntax.D1FunctionName
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0IdentList1
instance GHC.Generics.Datatype Language.Lua.Syntax.D1IdentList1
instance GHC.Generics.Constructor Language.Lua.Syntax.C1_0Ident
instance GHC.Generics.Datatype Language.Lua.Syntax.D1Ident
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.VariableList1 a)
instance GHC.Generics.Generic (Language.Lua.Syntax.VariableList1 a)
instance GHC.Base.Functor Language.Lua.Syntax.VariableList1
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.VariableList1 a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.VariableList1 a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.ExpressionList1 a)
instance GHC.Generics.Generic (Language.Lua.Syntax.ExpressionList1 a)
instance GHC.Base.Functor Language.Lua.Syntax.ExpressionList1
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.ExpressionList1 a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.ExpressionList1 a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Variable a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Variable a)
instance GHC.Base.Functor Language.Lua.Syntax.Variable
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Variable a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Variable a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.PrefixExpression a)
instance GHC.Generics.Generic (Language.Lua.Syntax.PrefixExpression a)
instance GHC.Base.Functor Language.Lua.Syntax.PrefixExpression
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.PrefixExpression a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.PrefixExpression a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.FunctionArgs a)
instance GHC.Generics.Generic (Language.Lua.Syntax.FunctionArgs a)
instance GHC.Base.Functor Language.Lua.Syntax.FunctionArgs
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.FunctionArgs a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.FunctionArgs a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.FunctionCall a)
instance GHC.Generics.Generic (Language.Lua.Syntax.FunctionCall a)
instance GHC.Base.Functor Language.Lua.Syntax.FunctionCall
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.FunctionCall a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.FunctionCall a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Statement a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Statement a)
instance GHC.Base.Functor Language.Lua.Syntax.Statement
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Statement a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Statement a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.ExpressionList a)
instance GHC.Generics.Generic (Language.Lua.Syntax.ExpressionList a)
instance GHC.Base.Functor Language.Lua.Syntax.ExpressionList
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.ExpressionList a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.ExpressionList a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.ReturnStatement a)
instance GHC.Generics.Generic (Language.Lua.Syntax.ReturnStatement a)
instance GHC.Base.Functor Language.Lua.Syntax.ReturnStatement
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.ReturnStatement a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.ReturnStatement a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Block a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Block a)
instance GHC.Base.Functor Language.Lua.Syntax.Block
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Block a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Block a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.FunctionBody a)
instance GHC.Generics.Generic (Language.Lua.Syntax.FunctionBody a)
instance GHC.Base.Functor Language.Lua.Syntax.FunctionBody
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.FunctionBody a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.FunctionBody a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Field a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Field a)
instance GHC.Base.Functor Language.Lua.Syntax.Field
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Field a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Field a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.FieldList a)
instance GHC.Generics.Generic (Language.Lua.Syntax.FieldList a)
instance GHC.Base.Functor Language.Lua.Syntax.FieldList
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.FieldList a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.FieldList a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.TableConstructor a)
instance GHC.Generics.Generic (Language.Lua.Syntax.TableConstructor a)
instance GHC.Base.Functor Language.Lua.Syntax.TableConstructor
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.TableConstructor a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.TableConstructor a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Expression a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Expression a)
instance GHC.Base.Functor Language.Lua.Syntax.Expression
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Expression a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Expression a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Unop a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Unop a)
instance GHC.Base.Functor Language.Lua.Syntax.Unop
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Unop a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Unop a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Binop a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Binop a)
instance GHC.Base.Functor Language.Lua.Syntax.Binop
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Binop a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Binop a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.FunctionName a)
instance GHC.Generics.Generic (Language.Lua.Syntax.FunctionName a)
instance GHC.Base.Functor Language.Lua.Syntax.FunctionName
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.FunctionName a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.FunctionName a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.IdentList1 a)
instance GHC.Generics.Generic (Language.Lua.Syntax.IdentList1 a)
instance GHC.Base.Functor Language.Lua.Syntax.IdentList1
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.IdentList1 a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.IdentList1 a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lua.Syntax.Ident a)
instance GHC.Generics.Generic (Language.Lua.Syntax.Ident a)
instance GHC.Base.Functor Language.Lua.Syntax.Ident
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lua.Syntax.Ident a)
instance Data.Data.Data a => Data.Data.Data (Language.Lua.Syntax.Ident a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Ident a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Block a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Statement a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.ReturnStatement a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.FunctionName a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Variable a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Expression a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.PrefixExpression a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.FunctionCall a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.FunctionArgs a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.FunctionBody a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.TableConstructor a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Field a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Binop a)
instance Text.PrettyPrint.Leijen.Pretty (Language.Lua.Syntax.Unop a)
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Ident
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.IdentList1
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Block
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Statement
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.ReturnStatement
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.FunctionName
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Variable
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.VariableList1
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Expression
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.ExpressionList
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.ExpressionList1
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.PrefixExpression
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.FunctionCall
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.FunctionArgs
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.FunctionBody
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.TableConstructor
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Field
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.FieldList
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Binop
instance Language.Lua.Syntax.Annotated Language.Lua.Syntax.Unop

module Language.Lua.Token
data Token

-- | and
TkAnd :: Token

-- | break
TkBreak :: Token

-- | do
TkDo :: Token

-- | else
TkElse :: Token

-- | elseif
TkElseif :: Token

-- | end
TkEnd :: Token

-- | false
TkFalse :: Token

-- | for
TkFor :: Token

-- | function
TkFunction :: Token

-- | goto
TkGoto :: Token

-- | if
TkIf :: Token

-- | in
TkIn :: Token

-- | local
TkLocal :: Token

-- | nil
TkNil :: Token

-- | not
TkNot :: Token

-- | or
TkOr :: Token

-- | repeat
TkRepeat :: Token

-- | return
TkReturn :: Token

-- | then
TkThen :: Token

-- | true
TkTrue :: Token

-- | until
TkUntil :: Token

-- | while
TkWhile :: Token

-- | +
TkPlus :: Token

-- | -
TkDash :: Token

-- | *
TkStar :: Token

-- | /
TkFslash :: Token

-- | %
TkPct :: Token

-- | ^
TkCarrot :: Token

-- | #
TkHash :: Token

-- | &amp;
TkAmp :: Token

-- | ~
TkTilde :: Token

-- | |
TkPipe :: Token

-- | &lt;&lt;
TkLShift :: Token

-- | &gt;&gt;
TkRShift :: Token

-- | //
TkDoubleFslash :: Token

-- | ==
TkDoubleEq :: Token

-- | ~=
TkNeq :: Token

-- | &lt;=
TkLeq :: Token

-- | &gt;=
TkGeq :: Token

-- | &lt;
TkLt :: Token

-- | &gt;
TkGt :: Token

-- | =
TkEq :: Token

-- | (
TkLParen :: Token

-- | )
TkRParen :: Token

-- | {
TkLBrace :: Token

-- | }
TkRBrace :: Token

-- | [
TkLBracket :: Token

-- | ]
TkRBracket :: Token

-- | ::
TkDoubleColon :: Token

-- | ;
TkSemi :: Token

-- | :
TkColon :: Token

-- | ,
TkComma :: Token

-- | .
TkDot :: Token

-- | ..
TkDoubleDot :: Token

-- | ...
TkTripleDot :: Token

-- | _
TkUnderscore :: Token

-- | '
TkQuote :: Token

-- | "
TkDoubleQuote :: Token
TkIdent :: String -> Token
TkStringLit :: String -> Token
TkIntLit :: String -> Token
TkFloatLit :: String -> Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_61Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_60Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_59Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_58Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_57Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_56Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_55Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_54Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_53Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_52Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_51Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_50Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_49Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_48Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_47Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_46Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_45Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_44Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_43Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_42Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_41Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_40Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_39Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_38Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_37Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_36Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_35Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_34Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_33Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_32Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_31Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_30Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_29Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_28Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_27Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_26Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_25Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_24Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_23Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_22Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_21Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_20Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_19Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_18Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_17Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_16Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_15Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_14Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_13Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_12Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_11Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_10Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_9Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_8Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_7Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_6Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_5Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_4Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_3Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_2Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_1Token
instance GHC.Generics.Constructor Language.Lua.Token.C1_0Token
instance GHC.Generics.Datatype Language.Lua.Token.D1Token
instance GHC.Show.Show Language.Lua.Token.Token
instance GHC.Generics.Generic Language.Lua.Token.Token
instance GHC.Classes.Eq Language.Lua.Token.Token
instance Data.Data.Data Language.Lua.Token.Token

module Language.Lua.Lexer

-- | <pre>
--   lex :: String -&gt; [L Token]
--   lex = <a>streamToList</a> . <a>runLexer</a> <a>luaLexer</a> ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lex "5+5"
--   [TkIntLit "5",TkPlus,TkIntLit "5"]
--   
--   &gt;&gt;&gt; lex "foo?"
--   [TkIdent "foo"*** Exception: Lexical error at :1:4
--   </pre>
luaLexer :: Lexer Token

-- | The lexical error exception
data LexicalError :: *
LexicalError :: SrictNotUnpackedPos -> LexicalError

-- | A stream of tokens
data TokenStream tok :: * -> *
TsToken :: tok -> TokenStream tok -> TokenStream tok
TsEof :: TokenStream tok
TsError :: LexicalError -> TokenStream tok

-- | Run a lexer on a string and produce a lazy stream of tokens
runLexer :: Lexer tok -> String -> String -> TokenStream (L tok)

-- | Convert a <a>TokenStream</a> to a list of tokens. Turn <a>TsError</a>
--   into a runtime <a>LexicalError</a> exception.
streamToList :: TokenStream tok -> [tok]

-- | Convert a <a>TokenStream</a> into either a token list or a
--   <a>LexicalError</a>. This function may be occasionally useful, but in
--   general its use is discouraged because it needs to force the whole
--   stream before returning a result.
streamToEitherList :: TokenStream tok -> Either LexicalError [tok]

module Language.Lua.Parser

-- | Parse a Lua file. May throw <a>LuaParseException</a>.
--   
--   <pre>
--   <a>parseLua</a> = <a>parseLuaWith</a> <a>luaChunk</a>
--   </pre>
parseLua :: String -> String -> Chunk NodeInfo

-- | Parse Lua code with the given grammar. May throw
--   <a>LuaParseException</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parseLuaWith luaExprssion "" "5+5"
--   Binop
--       (NodeInfo
--           { nodeLoc    = Loc (Pos "" 1 1 0) (Pos "" 1 3 2)
--           , nodeTokens = fromList [TkIntLit "5",TkPlus,TkIntLit "5"]
--           })
--       (Plus
--           (NodeInfo
--               { nodeLoc    = Loc (Pos "" 1 2 1) (Pos "" 1 2 1)
--               , nodeTokens = fromList [TkPlus]
--               }))
--       (Integer
--           (NodeInfo
--               { nodeLoc    = Loc (Pos "" 1 1 0) (Pos "" 1 1 0)
--               , nodeTokens = fromList [TkIntLit "5"]
--               })
--           "5")
--       (Integer
--           (NodeInfo
--               { nodeLoc    = Loc (Pos "" 1 3 2) (Pos "" 1 3 2)
--               , nodeTokens = fromList [TkIntLit "5"]
--               })
--            "5")
--   </pre>
--   
--   All AST nodes are <a>Functor</a>s over their annotation:
--   
--   <pre>
--   &gt;&gt;&gt; (() &lt;$) &lt;$&gt; parseLuaWith luaExpression "" "5+5"
--   Binop () (Plus ()) (Integer () "5") (Integer () "5")
--   </pre>
parseLuaWith :: LuaGrammar f -> String -> String -> f NodeInfo
data LuaParseException
LuaLexException :: !Pos -> LuaParseException
LuaParseException :: !(Report String [L Token]) -> LuaParseException
LuaAmbiguousParseException :: !(Report String [L Token]) -> LuaParseException
type LuaGrammar f = forall r. Grammar r String (Prod r String (L Token) (f NodeInfo))

-- | Grammar for a Lua chunk; i.e. a Lua compilation unit, defined as a
--   list of statements. This is the grammar you should use to parse real
--   Lua code.
luaChunk :: LuaGrammar Chunk

-- | Grammar for a single Lua statement. Mostly subsumed by
--   <a>luaChunk</a>.
luaStatement :: LuaGrammar Statement

-- | Grammar for a Lua expression. Provided for smaller REPL-like parsing
--   that operates only on expressions.
luaExpression :: LuaGrammar Expression

-- | AST node source location and constituent tokens. The tokens are
--   provided for style-checking purposes; with them, you may assert proper
--   whitespace protocol, alignment, trailing commas on table constructors,
--   and whatever other subjectivities.
data NodeInfo
NodeInfo :: !Loc -> !(Seq (L Token)) -> NodeInfo

-- | Source location; spans the entirety of the node.
[_nodeLoc] :: NodeInfo -> !Loc

-- | Parsed tokens involved in node production.
[_nodeTokens] :: NodeInfo -> !(Seq (L Token))
nodeLoc :: Lens' NodeInfo Loc
nodeTokens :: Lens' NodeInfo (Seq (L Token))

-- | A parsing report, which contains fields that are useful for presenting
--   errors to the user if a parse is deemed a failure. Note however that
--   we get a report even when we successfully parse something.
data Report e i :: * -> * -> *
Report :: Int -> [e] -> i -> Report e i

-- | The final position in the input (0-based) that the parser reached.
[position] :: Report e i -> Int

-- | The named productions processed at the final position.
[expected] :: Report e i -> [e]

-- | The part of the input string that was not consumed, which may be
--   empty.
[unconsumed] :: Report e i -> i

-- | The result of a parse.
data Result s e i a :: * -> * -> * -> * -> *

-- | The parser ended.
Ended :: Report e i -> Result s e i a

-- | The parser parsed a number of <tt>a</tt>s. These are given as a
--   computation, <tt><a>ST</a> s [a]</tt> that constructs the <tt>a</tt>s
--   when run. We can thus save some work by ignoring this computation if
--   we do not care about the results. The <a>Int</a> is the position in
--   the input where these results were obtained, the <tt>i</tt> the rest
--   of the input, and the last component is the continuation.
Parsed :: ST s [a] -> Int -> i -> ST s (Result s e i a) -> Result s e i a

-- | Return all parses from the result of a given parser. The result may
--   contain partial parses. The <a>Int</a>s are the position at which a
--   result was produced.
allParses :: (forall s. ST s (Result s e i a)) -> ([(a, Int)], Report e i)

-- | Return all parses that reached the end of the input from the result of
--   a given parser.
fullParses :: ListLike i t => (forall s. ST s (Result s e i a)) -> ([a], Report e i)

-- | Create a parser from the given grammar.
parser :: ListLike i t => (forall (r :: * -> * -> * -> *). Grammar r e (Prod r e t a)) -> i -> ST s (Result s e i a)

-- | See e.g. how far the parser is able to parse the input string before
--   it fails. This can be much faster than getting the parse results for
--   highly ambiguous grammars.
report :: ListLike i t => (forall s. ST s (Result s e i a)) -> Report e i
instance GHC.Generics.Selector Language.Lua.Parser.S1_0_1NodeInfo
instance GHC.Generics.Selector Language.Lua.Parser.S1_0_0NodeInfo
instance GHC.Generics.Constructor Language.Lua.Parser.C1_0NodeInfo
instance GHC.Generics.Datatype Language.Lua.Parser.D1NodeInfo
instance GHC.Classes.Eq Language.Lua.Parser.LuaParseException
instance GHC.Show.Show Language.Lua.Parser.NodeInfo
instance GHC.Generics.Generic Language.Lua.Parser.NodeInfo
instance GHC.Classes.Eq Language.Lua.Parser.NodeInfo
instance Data.Data.Data Language.Lua.Parser.NodeInfo
instance GHC.Base.Monoid Language.Lua.Parser.NodeInfo
instance Language.Lua.Parser.HasNodeInfo Language.Lua.Parser.NodeInfo
instance Language.Lua.Parser.HasNodeInfo (Data.Loc.L Language.Lua.Token.Token)
instance Language.Lua.Syntax.Annotated ast => Language.Lua.Parser.HasNodeInfo (ast Language.Lua.Parser.NodeInfo)
instance (Language.Lua.Parser.HasNodeInfo a, Language.Lua.Parser.HasNodeInfo b) => Language.Lua.Parser.HasNodeInfo (a, b)
instance (Language.Lua.Parser.HasNodeInfo a, Language.Lua.Parser.HasNodeInfo b, Language.Lua.Parser.HasNodeInfo c) => Language.Lua.Parser.HasNodeInfo (a, b, c)
instance (Language.Lua.Parser.HasNodeInfo a, Language.Lua.Parser.HasNodeInfo b, Language.Lua.Parser.HasNodeInfo c, Language.Lua.Parser.HasNodeInfo d) => Language.Lua.Parser.HasNodeInfo (a, b, c, d)
instance Language.Lua.Parser.HasNodeInfo a => Language.Lua.Parser.HasNodeInfo [a]
instance Language.Lua.Parser.HasNodeInfo a => Language.Lua.Parser.HasNodeInfo (Data.Sequence.Seq a)
instance Language.Lua.Parser.HasNodeInfo a => Language.Lua.Parser.HasNodeInfo (Data.List.NonEmpty.NonEmpty a)
instance Language.Lua.Parser.HasNodeInfo a => Language.Lua.Parser.HasNodeInfo (GHC.Base.Maybe a)
instance GHC.Show.Show Language.Lua.Parser.LuaParseException
instance GHC.Exception.Exception Language.Lua.Parser.LuaParseException
